(in-package #:unicode-data)

(defun parse-hexadecimal (value)
  (when (and (stringp value)
             (plusp (length value)))
    (parse-integer value :radix 16)))

(defmacro push-case-p (code-value casep place)
  `(cond ((not ,casep))
         ((and ,place
               (= (1+ (cdar ,place)) ,code-value))
          (setf (cdar ,place) ,code-value))
         ((and ,place
               (= (1- (caar ,place)) ,code-value))
          (setf (caar ,place) ,code-value))
         (t
          (push (cons ,code-value ,code-value) ,place))))

(defmacro push-mapping (from to place)
  `(cond ((not ,to))
         ((and ,place
               (= (1+ (cdaar ,place)) ,from)
               (= (1+ (cddar ,place)) ,to))
          (setf (cdaar ,place) ,from)
          (setf (cddar ,place) ,to))
         (t
          (push (cons (cons ,from ,from)
                      (cons ,to ,to))
                ,place))))

(defun generate-case-p (stream name caseps)
  (pprint-logical-block (stream caseps :prefix "  return " :suffix (coerce (list #\; #\newline) 'string))
    (pprint-exit-if-list-exhausted)
    (loop for (start . end) = (pprint-pop)
          for previous = nil then t
          when previous
            do (format stream " || ")
               (pprint-newline :fill stream)
          if (= start end)
            do (format stream "~a == 0x~x" name start)
          else if (= (1+ start) end)
            do (format stream "~a == 0x~x || " name start)
               (pprint-newline :fill stream)
               (format stream "~a == 0x~x" name end)
          else
            do (format stream "(~a >= 0x~x && ~a <= 0x~x)" name start name end)
          do (pprint-exit-if-list-exhausted))))

(defun generate-tocase (stream name mappings)
  (loop for ((from-start . from-end) . (to-start . to-end)) in mappings
        unless (or (= from-start from-end)
                   (= (1+ from-start) from-end))
          do (format stream "  if (~a >= 0x~x && ~a <= 0x~x) {~%    return ~a ~:[-~;+~] 0x~x;~%  }~%"
                     name from-start name from-end name
                     (> to-start from-start) (abs (- to-start from-start))))
  (format stream "  switch (~a) {~%" name)
  (loop for ((from-start . from-end) . (to-start . to-end)) in mappings
        when (or (= from-start from-end)
                 (= (1+ from-start) from-end))
          do (format stream "    case 0x~x: return 0x~x;~%" from-start to-start)
        when (= (1+ from-start) from-end)
          do (format stream "    case 0x~x: return 0x~x;~%" from-end to-end))
  (format stream "    default: return ~a;~%  }~%" name))

(defun range-less-p (x y)
  (or (> (- (cdr x) (car x))
         (- (cdr y) (car y)))
      (and (= (- (cdr x) (car x))
              (- (cdr y) (car y)))
           (< (car x) (car y)))))

(defun mapping-less-p (x y)
  (range-less-p (car x) (car y)))

(defun print-header (stream prefix url header)
  (format stream "~a This file is automatically generated.~%~a command: ninja -C build update-unicode~%~a url: ~a~%~a last modified: ~a~%~%"
          prefix prefix prefix url prefix (cdr (assoc :last-modified header))))

(defun parse (url)
  (destructuring-bind (status header stream url)
      (trivial-http:http-resolve url)
    (declare (ignore status resolve))
    (loop with upper-case-p = nil
          with lower-case-p = nil
          with both-case-p = nil
          with names = nil
          with uppercase-mappings = nil
          with lowercase-mappings = nil
          for row = (split-sequence:split-sequence #\; (read-line stream nil))
          for code-value = (parse-hexadecimal (first row))
          for character-name = (substitute #\_ #\Space (or (second row) ""))
          for uppercase-mapping = (parse-hexadecimal (nth 12 row))
          for lowercase-mapping = (parse-hexadecimal (nth 13 row))
          while (and row (> (length row) 13))
          unless (char= (char character-name 0) #\<)
            do (push (cons code-value character-name) names)
          do (push-mapping code-value uppercase-mapping uppercase-mappings)
             (push-mapping code-value lowercase-mapping lowercase-mappings)
             (push-case-p code-value uppercase-mapping lower-case-p)
             (push-case-p code-value lowercase-mapping upper-case-p)
             (push-case-p code-value (or uppercase-mapping lowercase-mapping) both-case-p)
          finally (return (values header upper-case-p lower-case-p both-case-p
                                  names uppercase-mappings lowercase-mappings)))))

(defun generate (c-file names-file &optional (url "http://unicode.org/Public/UNIDATA/UnicodeData.txt"))
  (multiple-value-bind (header upper-case-p lower-case-p both-case-p
                        names uppercase-mappings lowercase-mappings)
      (parse url)
    (let ((*print-right-margin* 132))
      (ninja:with-timestamp-preserving-stream (stream c-file)
        (print-header stream "//" url header)
        (format stream "bool clasp_isupper(claspCharacter cc) {~%")
        (generate-case-p stream "cc" (sort upper-case-p #'range-less-p))
        (format stream "}~%~%bool clasp_islower(claspCharacter cc) {~%")
        (generate-case-p stream "cc" (sort lower-case-p #'range-less-p))
        (format stream "}~%~%bool clasp_isboth(claspCharacter cc) {~%")
        (generate-case-p stream "cc" (sort both-case-p #'range-less-p))
        (format stream "}~%~%claspCharacter clasp_toupper(claspCharacter cc) {~%")
        (generate-tocase stream "cc" (sort uppercase-mappings #'mapping-less-p))
        (format stream "}~%~%claspCharacter clasp_tolower(claspCharacter cc) {~%")
        (generate-tocase stream "cc" (sort lowercase-mappings #'mapping-less-p))
        (format stream "}~%"))
      (let ((*print-radix* t)
            (*print-base* 16))
        (ninja:with-timestamp-preserving-stream (stream names-file)
          (print-header stream ";;;;" url header)
          (pprint-linear stream (reverse names) t))))))
