;;;
;;; This text is copied from the web page:
;;;   http://clang.llvm.org/docs/LibASTMatchersReference.html
;;;
;;; Copy the three sections for Node Matchers, Narrowing matchers and Traversal matchers
;;; into the files node.txt, narrowing.txt and traversal.txt
;;; and run this program

(defun extract-matcher-class (str)
  (let ((pos-< (position #\< str))
        (pos-> (position #\> str)))
    (ast-tooling:intern-matcher-keyword (subseq str (1+ pos-<) pos->))))

(defun parse-node-matcher-line (line)
  (let ((*readtable* (copy-readtable)))
    (setf (readtable-case *readtable*) :preserve)
    (with-input-from-string (sin line)
      (let ((a (extract-matcher-class (string (read sin))))
            (b (ast-tooling:intern-matcher-keyword (string (read sin))))
            (c (extract-matcher-class (string (read sin)))))
        (list a b c)))))

(defun substitute-colons (line)
  (substitute #\_ #\: line))

(defun parse-node-matcher-rules (rules)
  (with-open-file (sin rules :direction :input)
    (loop for line = (read-line sin nil :eof)
       until (eq line :eof)
       when (> (length line) 0)
       collect (parse-node-matcher-line (substitute-colons line)))))

(defun intern-argument (x y)
  (intern (format nil "~a-~a" (string-upcase x) (string-upcase (string y))) :keyword))

(defun extract-narrowing-arguments (arguments)
  (let ((cur arguments)
        results)
    (block args
      (loop
         (unless cur (return-from args (nreverse results)))
         (let* ((sym (car cur))
                (str (string sym)))
           (cond
             ((search "Matcher<" str)
              (push (extract-matcher-class str) results))
             ((eq sym '...)
              (push :... results))
             ((eq sym '|std__string|)
              (setf cur (cdr cur))
              (let ((arg (intern-argument "string" (car cur))))
                (push arg results)))
             ((eq sym '|StringRef|)
              (setf cur (cdr cur))
              (let ((arg (intern-argument "stringref" (car cur))))
                (push arg results)))
             ((eq sym '|unsigned|)
              (setf cur (cdr cur))
              (let ((arg (intern-argument "unsigned" (car cur))))
                (push arg results)))
             ((eq sym '|ValueT|)
              (setf cur (cdr cur))
              (let ((arg (intern-argument "valuet" (car cur))))
                (push arg results)))
             ((eq sym '|attr__Kind|)
              (setf cur (cdr cur))
              (let ((arg (intern-argument "kind" (car cur))))
                (push arg results)))
             ((eq sym '|UnaryExprOrTypeTrait|)
              (setf cur (cdr cur))
              (let ((arg (intern-argument "unary-expr-or-type-trait" (car cur))))
                (push arg results)))
             (t (error "Handle argument ~a" sym)))
           (setf cur (cdr cur)))))))

(defun parse-narrowing-matcher-line (line)
  (flet ((comma-reader (stream char)
           (declare (ignore char))
           (values)))
    (let ((*readtable* (copy-readtable)))
      (setf (readtable-case *readtable*) :preserve)
      (set-macro-character #\, #'comma-reader)
      (with-input-from-string (sin line)
        (let ((a (extract-matcher-class (string (read sin))))
              (b (ast-tooling:intern-matcher-keyword (string (read sin))))
              (c (loop for x = (read sin nil :eof)
                    until (eq x :eof)
                    collect x)))
          (list* a b (extract-narrowing-arguments c)))))))

(defun parse-narrowing-matcher-rules (rules)
  (with-open-file (sin rules :direction :input)
    (loop for line = (read-line sin nil :eof)
       until (eq line :eof)
       when (> (length line) 0)
       collect (parse-narrowing-matcher-line (substitute-colons line)))))

(defun extract-traversal-arguments (arguments)
  (let ((cur arguments)
        results)
    (block args
      (loop
         (unless cur (return-from args (nreverse results)))
         (let* ((sym (car cur))
                (str (string sym)))
           (cond
             ((search "Matcher<" str)
              (push (extract-matcher-class str) results))
             ((eq sym '...)
              (push :... results))
             ((eq sym '|InnerMatcher|) nil)
             ((eq sym '|Matcher|) nil)
             ((eq sym '|InnerType|) nil)
             ((eq sym '|Inner|) nil)
             ((eq sym '|ArgMatcher|) nil)
             ((eq sym '|ParamMatcher|) nil)
             ((eq sym '|Base|) nil)
             ((eq sym '|unsigned|)
              (setf cur (cdr cur))
              (let ((arg (intern-argument "unsigned" (car cur))))
                (push arg results)))
             (t (error "Handle argument ~a" sym)))
           (setf cur (cdr cur)))))))

(defun parse-traversal-matcher-line (line)
  (flet ((comma-reader (stream char)
           (declare (ignore char))
           (values)))
    (let ((*readtable* (copy-readtable)))
      (setf (readtable-case *readtable*) :preserve)
      (set-macro-character #\, #'comma-reader)
      (with-input-from-string (sin line)
        (let ((a (extract-matcher-class (string (read sin))))
              (b (ast-tooling:intern-matcher-keyword (string (read sin))))
              (c (loop for x = (read sin nil :eof)
                    until (eq x :eof)
                    collect x)))
          (list* a b (extract-traversal-arguments c)))))))

(defun parse-traversal-matcher-rules (rules)
  (with-open-file (sin rules :direction :input)
    (loop for line = (read-line sin nil :eof)
       until (eq line :eof)
       when (> (length line) 0)
       collect (parse-traversal-matcher-line (substitute-colons line)))))

(progn
  (setf *default-pathname-defaults* (truename "sys:modules;clang-tool;"))
  (with-open-file (fout #P"./rules.lisp" :direction :output :if-exists :supersede)
    (let ((node-matcher-rules (parse-node-matcher-rules #P"node-matchers.txt"))
          (narrowing-matcher-rules (parse-narrowing-matcher-rules #P"narrowing-matchers.txt"))
          (traversal-matcher-rules (parse-traversal-matcher-rules #P"traversal-matchers.txt")))
      (format fout "(defvar +node-matcher-rules+ ~%'~s)~%" node-matcher-rules)
      (format fout "(defvar +narrowing-matcher-rules+ ~%'~s)~%" narrowing-matcher-rules)
      (format fout "(defvar +traversal-matcher-rules+ ~%'~s)~%" traversal-matcher-rules))))
