;;; ------------------------------------------------------------
;;;
;;; Generic function dispatch compiler
;;;   This implements the algorithm described by Robert Strandh for fast generic function dispatch
;;;
;;;   clos:generic-function-call-history is an alist of (past-call-signature . effective-method-closure)
;;;      The effective-method-closure is generated by combin.lsp:combine-method-functions3 and
;;;        the fptr always points to combin.lsp:combine-method-functions3.lambda
;;;        and is closed over the method and the rest-methods.
;;;      The past-call-signature is a simple-vector of classes for class-specializers
;;;        or (list eql-spec) for eql specializers.  The CAR of eql-spec is the EQL value and the
;;;        argument passed to the generic function.
;;;        eql-spec is the result of calling spec_type.unsafe_cons()->memberEql(spec_position_arg)
;;;          in the function fill_spec_vector.
;;;          https://github.com/drmeister/clasp/blob/dev/src/core/genericFunction.cc#L194
;;;
;;; clos:*enable-fastgf* and :fast-dispatch feature.
;;;    When the :fast-dispatch feature exists and clos:*enable-fastgf* == t
;;;    then fast dispatch will be used for new generic functions.

(in-package :cmp)

;;; ------------------------------------------------------------
;;;
;;; Debugging code
;;;
;;; Add :DEBUG-CMPGF to *features* and recompile for lots of debugging info
;;;   during fastgf compilation and execution.
;;;
;;; Add :LOG-CMPGF to log fastgf messages during the slow path.
;;;    

#+(or)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf *echo-repl-read* t))

(defvar *log-gf* nil)
(defvar *debug-cmpfastgf-trace* nil)
(defvar *message-counter* nil)
#+debug-cmpfastgf
(progn
  (defun insert-message ()
    (when *debug-cmpfastgf-trace*
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 0) (jit-constant-i64 (incf *message-counter*))))))
  (defun debug-argument (arg arg-tag)
    (when *debug-cmpfastgf-trace*
      (insert-message)
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 1) arg))
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 2) arg-tag))))
  (defun debug-pointer (ptr)
    (when *debug-cmpfastgf-trace*
      (insert-message)
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 4) ptr))))
  (defun debug-arglist (ptr)
    (when *debug-cmpfastgf-trace*
      (insert-message)
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 3) ptr))))
  (defun debug-va_list (ptr)
    (when *debug-cmpfastgf-trace*
      (insert-message)
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 5) ptr))))
  (defun debug-stamp (ptr)
    (when *debug-cmpfastgf-trace*
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 6) ptr))))
  (defun debug-dispatch (ptr)
    (when *debug-cmpfastgf-trace*
      (irc-intrinsic-call "cc_dispatch_debug" (list (jit-constant-i32 7) ptr))))
  (defun debug-call (fn args)
    (when *debug-cmpfastgf-trace*
      (irc-intrinsic-call fn args)))
  (defmacro insert-message ()))

#-debug-cmpgf
(progn
  (defun insert-message())
  (defun debug-argument (arg arg-tag))
  (defun debug-pointer (ptr))
  (defun debug-arglist (ptr))
  (defun debug-va_list (ptr))
  (defun debug-stamp (ptr))
  (defun debug-dispatch (ptr))
  (defun debug-call (fn args))
  (defmacro insert-message ()))


(defmacro cf-log (fmt &body args)
  nil
  #+(or)`(core:bformat *debug-io* ,fmt ,@args))

;;; ------------------------------------------------------------
;;;
;;; Convert a generic function call-history to an internal representation
;;;   called a DTREE (dispatch-tree) made up of the structs below.

(defvar *accumulated-values* nil
  "Accumulate values that the dispatch function needs")
(defvar *outcomes* nil
  "Map effective methods and symbols to basic-blocks")
(defvar *gf-data-id* nil)
(defvar *gf-data* nil
  "Store the global variable that will store effective methods")
(defvar *bad-tag-bb*)
(defvar *eql-selectors*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Sanity check for slot index value
;;;
;;; index must the at position 1 of the optimized-slot-(reader|writer)
;;;
(eval-when (:compile-toplevel :execute :load-toplevel)
  (unless (= +optimized-slot-index-index+ 1)
    (error "The index of the slot index must be 1")))
(defstruct (optimized-slot-reader (:type vector) :named) index #| << must be here |# effective-method-function slot-name method class)
(defstruct (optimized-slot-writer (:type vector) :named) index #| << must be here |# effective-method-function slot-name method class)
(defstruct (klass (:type vector) :named) stamp name)
(defstruct (outcome (:type vector) :named) outcome)
(defstruct (match (:type vector) :named) outcome)
(defstruct (single (:include match) (:type vector) :named) stamp class)
(defstruct (range (:include match) (:type vector) :named) first-stamp last-stamp reversed-classes)
(defstruct (skip (:include match) (:type vector) :named))
(defstruct (node (:type vector) :named) (eql-specializers (make-hash-table :test #'eql) :type hash-table)
           (class-specializers nil :type list))


(defstruct (argument-holder (:type vector) :named) (history nil) va-list gf-args gf)

(defun argument-next (arguments)
  (let ((arg (irc-va_arg (argument-holder-va-list arguments) %t*%)))
    (push arg (argument-holder-history arguments))
    arg))

(defstruct (dtree (:type vector) :named) root)

(defstruct (spec-vec-iterator (:type vector))
  index vector)

(defun spec-vec-iterator-value (spec-vec)
  (svref (spec-vec-iterator-vector spec-vec) (spec-vec-iterator-index spec-vec)))

(defun spec-vec-iterator-advance (spec-vec)
  (incf (spec-vec-iterator-index spec-vec)))

#++
(defun parse-call-history-entry (entry)
  (values (butlast entry) (car (last entry))))

(defun dtree-add-call-history (dtree call-history)
  "Add call-history for one generic-function to the dtree"
  (dolist (one call-history)
    (let ((signature (car one))
	  (outcome (cdr one)))
      #++(parse-call-history-entry one)
      (if (> (length signature) 0)
          (progn
            (when (null (dtree-root dtree)) (setf (dtree-root dtree) (make-node)))
            (node-add (dtree-root dtree) (svref signature 0) 1 signature outcome)
            (optimize-nodes (dtree-root dtree)))
          (progn
            (setf (dtree-root dtree) (make-outcome :outcome outcome)))))))


(defun eql-specializer-p (spec)
  "Return t if the spec is an eql specializer - they are represented as CONS cells
   with the value in the CAR  - the 'EQL symbol has been removed"
  (consp spec))

(defun node-add (node spec argument-index specializers goal)
  (if (eql-specializer-p spec)
      (node-eql-add node spec argument-index specializers goal)
      (node-class-add node spec argument-index specializers goal)))

(defun insert-sorted (item lst &optional (test #'<) (key #'single-stamp))
  (if (null lst)
      (list item)
      (if (funcall test (funcall key item) (funcall key (car lst)))
          (cons item lst) 
          (cons (car lst) (insert-sorted item (cdr lst) test key)))))


(defun ensure-outcome (argument-index specs goal)
  (if (>= argument-index (length specs))
      (make-outcome :outcome goal)
      (let ((node (make-node)))
        (node-add node (svref specs argument-index) (1+ argument-index) specs goal)
        node)))

(defun safe-class-name (class-designator)
  (cond
    ((symbolp class-designator) class-designator)
    ((clos::classp class-designator) (class-name class-designator))
    ((klass-p class-designator) (klass-name class-designator))
    (t (error "Illegal class-designator"))))

(defun node-class-add (node spec argument-index specializers goal)
  (or (<= argument-index (length specializers))
      (error "Overflow in argument-index ~a must be <= ~a" argument-index (length specializers)))
  (if spec
      (let* ((stamp (cond
                      ((clos:classp spec) (core:class-stamp-for-instances spec))
                      ((symbolp spec) (core:class-stamp-for-instances (find-class spec)))
                      ((klass-p spec) (klass-stamp spec))
                      (t (error "Illegal specializer ~a" spec))))
             (match (find stamp (node-class-specializers node) :test #'eql :key #'single-stamp)))
        (if match
            (if (outcome-p (match-outcome match))
                (warn "The dispatch function has two selectors with different outcomes~%---- argument-index: ~a~%---- specializers: ~a~%---- goal: ~a~%---- current node: ~a~%---- stamp: ~a~%---- match: ~a" argument-index specializers goal node stamp match)
                (node-add (match-outcome match) (svref specializers argument-index) (1+ argument-index) specializers goal))
            (setf (node-class-specializers node)
                  (insert-sorted (make-single :stamp stamp
                                              :class spec
                                              :outcome (ensure-outcome argument-index specializers goal))
                                 (node-class-specializers node)))))
      (let ((match (first (node-class-specializers node))))
        (if match
            (node-add (match-outcome match) (svref specializers argument-index) (1+ argument-index) specializers goal)
            (setf (node-class-specializers node)
                  (list (make-skip :outcome (ensure-outcome argument-index specializers goal))))))))

(defun node-eql-add (node spec argument-index specializers goal)
  (let* ((eql-value (car spec))
	 (eql-ht (node-eql-specializers node))
         (node (gethash eql-value eql-ht nil)))
    (if node
        (progn
          (or (node-p node) (error "The node ~a must be of node type" node))
          (node-add node (svref specializers argument-index) (1+ argument-index) specializers goal))
        (let ((outcome (ensure-outcome argument-index specializers goal)))
          (setf (gethash eql-value eql-ht) outcome)))))

(defun extends-range-p (prev-last-stamp prev-outcome next)
  (and (= (1+ prev-last-stamp) (single-stamp next))
       (equalp prev-outcome (single-outcome next))))

(defun optimize-node-with-class-specializers (node)
  (let ((class-specializers (node-class-specializers node))
        merged merged-specializers)
    (dolist (head class-specializers)
      (let ((prev (car merged-specializers)))
        (cond
          ((null prev)
           ;; There is no prev head or range
           (push head merged-specializers))
          ((and (range-p prev)
                (extends-range-p (range-last-stamp prev)
                                 (range-outcome prev)
                                 head))
           ;; The new head extends the previous range
           (incf (range-last-stamp prev))
           (push (single-class head) (range-reversed-classes prev))
           (setf merged t))
          ((range-p prev)
           ;; The new head doesn't extend the prev range
           (push head merged-specializers))
          ((extends-range-p (single-stamp prev)
                            (single-outcome prev)
                            head)
           ;; prev was a single match but with the new head
           ;; they make a range.  Pop prev from merged-specializers
           ;; and push a range-match
           (pop merged-specializers)
           (push (make-range :first-stamp (single-stamp prev)
                             :last-stamp (single-stamp head)
                             :reversed-classes (list (single-class head)
                                                     (single-class prev))
                             :outcome (single-outcome head))
                 merged-specializers)
           (setf merged t))
          (t (push head merged-specializers)))))
    (when merged
      (setf (node-class-specializers node) (nreverse merged-specializers)))))

(defun skip-node-p (node)
  (let ((class-specializers (node-class-specializers node)))
    (and (= 1 (length class-specializers)) (skip-p (car class-specializers)))))

(defun optimize-node (node)
  "Create a list from the argument list and merge matches
   that can be considered adjacent into a range object."
  (if (skip-node-p node)
      nil ;; There is one class-specializer and it's a skip class-specializer do nothing
      (optimize-node-with-class-specializers node)))

(defun optimize-nodes (node-or-outcome)
  (when (node-p node-or-outcome)
    (dolist (spec (node-class-specializers node-or-outcome))
      (let ((child-node-or-outcome (match-outcome spec)))
	(optimize-nodes child-node-or-outcome)))
    (optimize-node node-or-outcome)))
	    


;;; ------------------------------------------------------------
;;;
;;; Generate Common Lisp code for a fastgf dispatcher given a
;;;   DTREE internal representation


(defun compile-remaining-eql-tests (eql-tests arg args orig-args)
  (if (null eql-tests)
      nil
      (let ((eql-test (car eql-tests))
	    (eql-rest (cdr eql-tests)))
	`(if (eql ,arg ',(car eql-test))
	     ,(compile-node-or-outcome (second eql-test) args orig-args)
	     ,(if eql-rest
		  (compile-remaining-eql-tests eql-rest arg args orig-args))))))

(defun compile-eql-specializers (node arg args orig-args)
  (let ((eql-tests (let (values)
		     (maphash (lambda (key value)
				(push (list key value) values))
			      (node-eql-specializers node))
		     values)))
    (let ((result (compile-remaining-eql-tests eql-tests arg args orig-args)))
      (if result
	  (list result)
	  nil))))


(defun compile-class-binary-search (matches stamp-var args orig-args)
  (cond
    ((null matches)
     `(no-applicable-method orig-args))
    ((= (length matches) 1)
     (let ((match (car matches)))
       (if (single-p match)
	   `(if (= ,stamp-var ,(single-stamp match))
		,(compile-node-or-outcome (single-outcome match) args orig-args)
		(go miss))
	   `(if (and (>= ,stamp-var ,(range-first-stamp match)) (<= ,stamp-var ,(range-last-stamp match)))
		,(compile-node-or-outcome (match-outcome match) args orig-args)
		(go miss)))))
    (t
     (let* ((len-div-2 (floor (length matches) 2))
	    (left-matches (subseq matches 0 len-div-2))
	    (right-matches (subseq matches len-div-2))
	    (right-head (car right-matches))
	    (right-stamp (if (single-p right-head)
			     (single-stamp right-head)
			     (range-first-stamp right-head))))
       `(if (< ,stamp-var ,right-stamp)
	    ,(compile-class-binary-search left-matches stamp-var args orig-args)
	    ,(compile-class-binary-search right-matches stamp-var args orig-args))))))

(defun compile-class-specializers (node arg args orig-args)
  (let ((stamp-var (gensym "STAMP")))
    `(let ((,stamp-var (core:class-stamp-for-instances (class-of ,arg))))
       ,(compile-class-binary-search (node-class-specializers node) stamp-var args orig-args))))

(defvar *map-tag-outcomes* (make-hash-table))

(defun gather-outcomes (outcome)
  (let ((tag (intern (core:bformat nil "T%s" (hash-table-count *map-tag-outcomes*)))))
    (setf (gethash tag *map-tag-outcomes*) outcome)
    tag))

(defun compile-outcome (node args orig-args)
  `(go ,(gather-outcomes (outcome-outcome node))))

(defun compile-node (node args orig-args)
  (let ((arg (gensym "ARG")))
    `(let ((,arg (va-arg ,args)))
       ,@(compile-eql-specializers node arg args orig-args)
       ,(compile-class-specializers node arg args orig-args))))

(defun compile-node-or-outcome (node-or-outcome args orig-args)
  (if (outcome-p node-or-outcome)
      (compile-outcome node-or-outcome args orig-args)
      (compile-node node-or-outcome args orig-args)))

(defun compiled-dtree-form (dtree)
  (let ((vargs (gensym "VARGS"))
	(orig-vargs (gensym "ORIG-VARGS"))
	(*map-tag-outcomes* (make-hash-table)))
    `(lambda (,orig-vargs &aux (,vargs (copy-vargs ,orig-vargs)))
       (tagbody
	  ,(compile-node-or-outcome (dtree-root dtree) vargs `(copy-vargs ,vargs))
	  ,@(let (result)
                 (maphash (lambda (key value)
                            (push value result)
                            (push key result))
                          *map-tag-outcomes*)
                 result)
	miss
	  (no-applicable-method ,vargs)))))

(defun draw-node (fout node)
  (cond
    ((null node)
     #+(or)(let ((nodeid (gensym)))
	     (core:bformat fout "%s [shape = circle];\n" (string nodeid))
	     (core:bformat fout "%s [label = \"nil\"];\n" (string nodeid))
	     nodeid)
     nil)
    ((outcome-p node)
     (let ((nodeid (gensym)))
       (core:bformat fout "%s [shape=ellipse,label=\"HIT-%s\"];\n" (string nodeid) (core:object-address (outcome-outcome node)))
       nodeid))
    ((node-p node)
     (let* ((nodeid (gensym))
	    (idx 0)
	    (eql-entries (let (result)
                           (maphash (lambda (key value)
                                      (push (list (prog1 idx (incf idx))
                                                  (core:bformat nil "eql %s" key)
                                                  (draw-node fout value))
                                            result))
                                    (node-eql-specializers node))
                           result)
              #+(or)(loop for key being the hash-keys of (node-eql-specializers node)
                       using (hash-value value)
                       collect (list (prog1 idx (incf idx))
                                     (core:bformat nil "eql %s" key)
                                     (draw-node fout value))))
	    (class-entries
             (let (result)
               (dolist (x (node-class-specializers node))
                 (push (list (prog1 idx (incf idx))
                             (cond
                               ((single-p x)
                                (core:bformat nil "%s;%s" (single-stamp x) (safe-class-name (single-class x))))
                               ((range-p x)
                                (core:bformat nil "%s-%s;%s" (range-first-stamp x) (range-last-stamp x) (mapcar #'safe-class-name (reverse (range-reversed-classes x)))))
                               ((skip-p x)
                                (core:bformat nil "SKIP"))
                               (t (error "Unknown class-specializer type ~a" x)))
                             (draw-node fout (match-outcome x))) result))
               (let ((rev-res (reverse result)))
                 rev-res)))
	    (entries (append eql-entries class-entries)))
       (core:bformat fout "%s [shape = record, label = \"" (string nodeid))
       (let ((first-one t))
         (dolist (x entries)
           (if first-one
               (setq first-one nil)
               (core:bformat fout "| "))
           (core:bformat fout " <f%s> %s " (first x) (second x)))
         (core:bformat fout "\" ];\n"))
       (mapc (lambda (x)
               (core:bformat fout "%s:<f%s> -> %s;\n" (string nodeid) (first x) (string (third x))))
             entries)
       #+(or)(loop for x in entries
                do (core:bformat fout "~a:<f~a> -> ~a;\n" (string nodeid) (first x) (string (third x))))
       nodeid))
    (t (error "Handle draw-node for ~a" node )
       #+(or)(let ((id (gensym)))
	       (core:bformat fout "~a [ label = \"%s\"];\n" id node)
	       id))))


;;; ------------------------------------------------------------
;;;
;;; Generate a graphviz representation of a DTREE
;;;

(defmacro with-graph ((name fout &rest open-args) &body body)
  `(with-open-file (,fout ,@open-args)
     (core:bformat ,fout "digraph %s {\n" ,name)
     ,@body
     (core:bformat ,fout "}\n")))

(defun draw-graph (pathname dtree)
  (with-graph ("G" fout pathname :direction :output)
    (core:bformat fout "graph [ rankdir = \"LR\"];\n")
    (let ((startid (gensym)))
      (core:bformat fout "%s [ label = \"Start\", shape = diamond ];\n" (string startid))
      (core:bformat fout "%s -> %s;\n" (string startid) (string (draw-node fout (dtree-root dtree)))))))

(defun register-runtime-data (value table)
  (let ((index (prog1 *gf-data-id* (incf *gf-data-id*))))
    (setf (gethash value table) index)
    index))

(defun lookup-eql-selector (eql-test)
  (let ((tagged-immediate (core:create-tagged-immediate-value-or-nil eql-test)))
    (if tagged-immediate
	(irc-int-to-ptr (jit-constant-i64 tagged-immediate) %t*%)
	(let ((eql-selector-id (gethash eql-test *eql-selectors*)))
	  (unless eql-selector-id
            (setf eql-selector-id (register-runtime-data eql-test *eql-selectors*)))
	  (let* ((eql-selector (irc-load (irc-gep *gf-data*
                                                  (list (jit-constant-size_t 0)
                                                        (jit-constant-size_t eql-selector-id))) "load")))
	    eql-selector)))))

;;; ------------------------------------------------------------
;;;
;;; Generate an LLVM Module that codes for the dispatch function
;;;   described by a DTREE.
;;;

(defun codegen-remaining-eql-tests (arguments eql-tests eql-fail-branch arg)
  (cf-log "codegen-remaining-eql-tests\n")
  (if (null eql-tests)
      (irc-br eql-fail-branch)
      (let* ((eql-test (car eql-tests))
	     (eql-rest (cdr eql-tests))
	     (eql-spec (first eql-test))
	     (eql-outcome (second eql-test))
	     (eql-selector (lookup-eql-selector eql-spec))
	     (eq-cmp (irc-icmp-eq arg eql-selector))
	     (eql-branch (irc-basic-block-create "eql-branch"))
	     (else-eql-test (irc-basic-block-create "else-eql-test")))
	(irc-cond-br eq-cmp eql-branch else-eql-test)
	(irc-begin-block else-eql-test)
	(let* ((eql-i32 (irc-intrinsic-call "cc_eql" (list arg eql-selector)))
	       (eql-cmp (irc-icmp-eq eql-i32 (jit-constant-i32 1)))
	       (next-eql-test (irc-basic-block-create "next-eql-test")))
	  (irc-cond-br eql-cmp eql-branch next-eql-test)
	  (irc-begin-block next-eql-test)
	  (codegen-remaining-eql-tests arguments eql-rest eql-fail-branch arg))
	(irc-begin-block eql-branch)
	(codegen-node-or-outcome arguments eql-outcome))))

(defun codegen-eql-specializers (arguments node arg)
  (cf-log "codegen-eql-specializers\n")
  (let ((eql-tests (let (result)
                     (maphash (lambda (key value)
                                (push (list key value) result))
                              (node-eql-specializers node))
                     result)
          #+(or)(loop for key being the hash-keys of (node-eql-specializers node)
                   using (hash-value value)
                   collect (list key value)))
	(on-to-class-specializers (irc-basic-block-create "on-to-class-specializers")))
    (codegen-remaining-eql-tests arguments eql-tests on-to-class-specializers arg)
    (irc-begin-block on-to-class-specializers)))

#++(defun gather-outcomes (outcome)
  (let ((tag (intern (core:bformat nil "T%s" (hash-table-count *map-tag-outcomes*)))))
    (setf (gethash tag *map-tag-outcomes*) outcome)
    tag))


(defun codegen-slot-reader (arguments outcome)
  (cf-log "entered codegen-slot-reader\n")
;;; If the (cdr outcome) is a fixnum then we can generate code to read the slot
;;;    directly and remhash the outcome from the *outcomes* hash table.
;;; otherwise create an entry for the outcome and call the slot reader.
  (let ((gf-data-id (register-runtime-data outcome *outcomes*))
	(effective-method-block (irc-basic-block-create "effective-method")))
    (irc-branch-to-and-begin-block effective-method-block)
    (let ((slot-read-info
            (irc-load (irc-gep *gf-data*
                               (list (jit-constant-size_t 0)
                                     (jit-constant-size_t gf-data-id))) "load")))
      (cf-log "Ad\n")
      (irc-intrinsic-call "llvm.va_end" (list (irc-pointer-cast (argument-holder-va-list arguments) %i8*% "local-arglist-i8*")))
      (cf-log "Ada\n")
      (let ((opt-data (optimized-slot-reader-index outcome)))
        (cf-log "Ae\n")
        (irc-ret
         (cond
           ((fixnump opt-data)
            ;; FIXME   The argument-holder-gf-args is a vaslist!!!! not a va_list - they are just coincident!!!
            (irc-intrinsic-call "cc_vaslist_end" (list (argument-holder-gf-args arguments)))
            (let ((value (irc-intrinsic-call #+debug-slot-accessors "cc_dispatch_slot_reader_index_debug"
                                             #-debug-slot-accessors "cc_dispatch_slot_reader_index"
                                             (list (jit-constant-size_t opt-data) (first (argument-holder-history arguments))))))
              (irc-intrinsic-call "cc_bound_or_error" (list slot-read-info (first (argument-holder-history arguments)) value))))
           ((consp opt-data)
            (cf-log "Generating slot reader for cons at %s\n" (core:object-address opt-data))
            (let* ((value (irc-intrinsic-call "cc_dispatch_slot_reader_cons" (list slot-read-info))))
              (irc-intrinsic-call "cc_bound_or_error" (list slot-read-info (first (argument-holder-history arguments)) value))))
           (t (error "Unknown opt-data type ~a" opt-data))))))))

(defun codegen-slot-writer (arguments outcome)
  (cf-log "codegen-slot-writer\n")
;;; If the (optimized-slot-writer-data outcome) is a fixnum then we can generate code to read the slot
;;;    directly and remhash the outcome from the *outcomes* hash table.
;;; otherwise create an entry for the outcome and call the slot reader.
  (let ((gf-data-id (register-runtime-data outcome *outcomes*))
	(effective-method-block (irc-basic-block-create "effective-method")))
    (irc-branch-to-and-begin-block effective-method-block)
    (let ((slot-write-info
            (irc-load (irc-gep *gf-data*
                               (list (jit-constant-size_t 0)
                                     (jit-constant-size_t gf-data-id))) "write")))
      (irc-intrinsic-call "llvm.va_end" (list (irc-pointer-cast (argument-holder-va-list arguments) %i8*% "local-arglist-i8*")))
      (irc-intrinsic-call "cc_vaslist_end" (list (argument-holder-gf-args arguments)))
      (let ((opt-data (optimized-slot-writer-index outcome)))
        (irc-ret
         (cond
           ((fixnump opt-data)
            (irc-intrinsic-call #+debug-slot-accessors "cc_dispatch_slot_writer_index_debug"
                                #-debug-slot-accessors "cc_dispatch_slot_writer_index"
                                (list #+debug-slot-accessors effective-method
                                      (second (argument-holder-history arguments)) ; value
                                      (jit-constant-size_t opt-data) ; index
                                      (first (argument-holder-history arguments))))) ; instance
           ((consp opt-data)
            (let ()
              (irc-intrinsic-call "cc_dispatch_slot_writer_cons" (list (second (argument-holder-history arguments)) ; falue
                                                                       slot-write-info))))
           (t (error "Unknown opt-data ~a" opt-data))))))))

(defun codegen-effective-method-call (arguments outcome)
  (cf-log "codegen-effective-method-call\n")
  (let ((gf-data-id (register-runtime-data outcome *outcomes*))
	(effective-method-block (irc-basic-block-create "effective-method")))
    (irc-branch-to-and-begin-block effective-method-block)
    (let ((effective-method
            (irc-load (irc-gep *gf-data*
                               (list (jit-constant-size_t 0)
                                     (jit-constant-size_t gf-data-id))) "load")))
      (debug-pointer (irc-ptr-to-int
                      (irc-gep *gf-data*
                               (list (jit-constant-size_t 0)
                                     (jit-constant-size_t gf-data-id))) %uintptr_t%))
      (debug-call "debugPointer" (list (irc-bit-cast effective-method %i8*%)))
      (irc-intrinsic-call "llvm.va_end" (list (irc-pointer-cast (argument-holder-va-list arguments) %i8*% "local-arglist-i8*")))
      ;; This is where I could insert the slot reader if the effective method wraps a single accessor
      ;;
      (debug-dispatch effective-method)
      (irc-ret (irc-intrinsic-call "cc_dispatch_effective_method" (list effective-method
                                                                        (argument-holder-gf arguments)
                                                                        (argument-holder-gf-args arguments)) "ret")))))

(defun codegen-outcome (arguments node)
  (cf-log "codegen-outcome\n")
  ;; The effective method will be found in a slot in the modules *gf-data* array
  ;;    the slot index will be in gf-data-id
  (let* ((outcome (outcome-outcome node))
         (existing-effective-method-block (gethash outcome *outcomes*)))
    (when *log-gf*
      (core:bformat *log-gf* "About to codegen-outcome -> %s\n" outcome))
    (if existing-effective-method-block
	(irc-br existing-effective-method-block)
        (cond
          ((optimized-slot-reader-p outcome)
           (codegen-slot-reader arguments outcome))
          ((optimized-slot-writer-p outcome)
           (codegen-slot-writer arguments outcome))
          (t (codegen-effective-method-call arguments outcome))))))

(defun codegen-class-binary-search (arguments matches stamp-var)
  (cf-log "codegen-class-binary-search\n")
  (insert-message)
  (cond
    ((null matches)
     (irc-br (gethash :miss *outcomes*)))
    ((= (length matches) 1)
     (let ((match (car matches)))
       (if (single-p match)
	   (let ((cmpeq (irc-icmp-eq stamp-var (jit-constant-i64 (single-stamp match)) "eq"))
		 (true-branch (irc-basic-block-create "match"))
		 (false-branch (irc-basic-block-create "cont")))
	     (irc-cond-br cmpeq true-branch false-branch)
	     (irc-begin-block true-branch)
	     (codegen-node-or-outcome arguments (single-outcome match))
	     (irc-begin-block false-branch)
	     (irc-br (gethash :miss *outcomes*)))
	   (let ((ge-first-branch (irc-basic-block-create "gefirst"))
		 (le-last-branch (irc-basic-block-create "lelast"))
		 (miss-branch (gethash :miss *outcomes*))
		 (cmpge (irc-icmp-sge stamp-var (jit-constant-i64 (range-first-stamp match)) "ge")))
	     (irc-cond-br cmpge ge-first-branch miss-branch)
	     (irc-begin-block ge-first-branch)
	     (let ((cmple (irc-icmp-sle stamp-var (jit-constant-i64 (range-last-stamp match)) "le")))
	       (irc-cond-br cmple le-last-branch miss-branch)
	       (irc-begin-block le-last-branch)
	       (codegen-node-or-outcome arguments (match-outcome match)))))))
    (t
     (let* ((len-div-2 (floor (length matches) 2))
	    (left-matches (subseq matches 0 len-div-2))
	    (right-matches (subseq matches len-div-2))
	    (right-head (car right-matches))
	    (right-stamp (if (single-p right-head)
			     (single-stamp right-head)
			     (range-first-stamp right-head))))
       (let ((lt-branch (irc-basic-block-create "lt-branch"))
	     (gte-branch (irc-basic-block-create "gte-branch"))
	     (cmplt (irc-icmp-slt stamp-var (jit-constant-i64 right-stamp) "lt")))
	 (irc-cond-br cmplt lt-branch gte-branch)
	 (irc-begin-block lt-branch)
	 (codegen-class-binary-search arguments left-matches stamp-var)
	 (irc-begin-block gte-branch)
	 (codegen-class-binary-search arguments right-matches stamp-var))))))

(defun codegen-arg-stamp (arg)
  (cf-log "codegen-arg-stamp\n")
  "Return a uintptr_t llvm::Value that contains the stamp for this object"
  ;; First check the tag
  (let ((stamp (irc-intrinsic-call "cc_read_stamp" (list (irc-bit-cast arg %i8*%)))))
    (debug-stamp stamp)
    stamp))

(defun codegen-class-specializers (arguments node arg)
  (cf-log "entered codegen-class-specializer\n")
      (let ((arg-stamp (codegen-arg-stamp arg)))
        (codegen-class-binary-search arguments (node-class-specializers node) arg-stamp)))

(defun codegen-skip-node (arguments node)
  (cf-log "entered codegen-skip-node\n")
  ;;;
  ;;; Here I could do an optimization.
  ;;;   If it's skip-nodes all the way to the outcome
  ;;;    - then just do the outcome
  (let ((skip-node (first (node-class-specializers node))))
    (codegen-node-or-outcome arguments (skip-outcome skip-node))))

(defun codegen-node (arguments node)
  (cf-log "entered codegen-node\n")
  (let ((arg (argument-next arguments)))
    (debug-call "debugPointer" (list (irc-bit-cast arg %i8*%)))
    (insert-message)
    (if (skip-node-p node)
        (codegen-skip-node arguments node)
        (progn
          (codegen-eql-specializers arguments node arg)
          (codegen-class-specializers arguments node arg)))))

(defun codegen-node-or-outcome (arguments node-or-outcome)
  (cf-log "entered codegen-node-or-outcome\n")
  (insert-message)
  (if (outcome-p node-or-outcome)
      (codegen-outcome arguments node-or-outcome)
      (codegen-node arguments node-or-outcome)))

;;; --------------------------------------------------
;;;
;;; Debugging a generic function dispatcher
;;;
(defvar *disp-fn-name*)
(defvar *startup-fn-name*)
(defvar *shutdown-fn-name*)
(defvar *sorted-roots*)
(defvar *generic-function*)


(defun debug-save-dispatcher (gf module disp-fn startup-fn shutdown-fn sorted-roots &optional (output-path #P"/tmp/dispatcher.ll"))
  "Save everything about the generic function so that it can be saved to a file and then edited and re-installed"
  (setq *disp-fn-name* (llvm-sys:get-name disp-fn)
        *startup-fn-name* (llvm-sys:get-name startup-fn)
        *shutdown-fn-name* (llvm-sys:get-name shutdown-fn)
        *sorted-roots* sorted-roots
        *generic-function* gf)
  ;;  (cmp::gf-log-sorted-roots sorted-roots)
  (let ((fout (open output-path :direction :output)))
    (unwind-protect (llvm-sys:dump-module module fout)
      (close fout))))
#||
(defun debug-load-dispatcher (function-name)
  (let* ((module (llvm-sys:parse-irfile #P"/tmp/dispatcher.ll" cmp:*llvm-context*))
         (disp-fn (llvm-sys:get-function module *disp-fn-name*))
         (startup-fn (llvm-sys:get-function module *startup-fn-name*))
         (shutdown-fn (llvm-sys:get-function module *shutdown-fn-name*))
         (compiled-dispatcher (jit-add-module-return-dispatch-function
                               module
                               disp-fn startup-fn shutdown-fn *sorted-roots*)))
    (clos::safe-set-funcallable-instance-function *generic-function* compiled-dispatcher)))
||#

(defun gather-sorted-outcomes (eql-selectors outcomes)
  (labels ((extract-outcome (outcome)
             ;; An outcome is an effective-method or an optimized slot reader or writer.
             ;; Figure out which case it is and return the effective-method or the
             ;;   optimization info necessary to evaluate the slot reader or writer.
             (let ((oc (cdr outcome)))
               (if (consp oc)
                   (cdr oc)
                   oc))))
    (let ((values nil))
      (maphash (lambda (k v)
                 (push (cons v k) values))
               eql-selectors)
      (maphash (lambda (k v)
                 (unless (eq k :miss)
                   (push (cons v k) values)))
               outcomes)
      (let ((sorted (sort values #'< :key #'car)))
        (mapcar #'extract-outcome sorted)))))

(defun optimized-call-history (generic-function)
  (let* ((call-history (clos:generic-function-call-history generic-function))
         (specializer-profile (clos:generic-function-specializer-profile generic-function))
         (specializer-length (let ((pos (position-if #'identity specializer-profile :from-end t)))
                               (if pos
                                   (1+ pos)
                                   0)))
         (profiled (make-hash-table :test #'equalp)))
    (unless (every #'consp call-history)
      (error "The call history for ~a is not an alist: ~a" generic-function call-history))
    (or specializer-profile
        (error "The specializer-profile for ~a is NIL" generic-function))
    (dolist (entry call-history)
      (let ((key (car entry))
            (outcome (cdr entry))
            (new-key (make-array specializer-length :initial-element nil)))
        (dotimes (i specializer-length)
          (setf (svref new-key i)
                (if (svref specializer-profile i)
                    (let ((val (svref key i)))
                      (if (consp val)
                          (list (car val))
                          val))
                    nil)))
        (setf (gethash new-key profiled) outcome)))
    #+(or)(loop for entry in call-history
             for key = (car entry)
             for outcome = (cdr entry)
             for new-key = (make-array specializer-length :initial-element nil)
             do (loop for i from 0 below specializer-length
                   do (setf (svref new-key i)
                            (if (svref specializer-profile i)
                                (let ((val (svref key i)))
                                  (if (consp val)
                                      (list (car val))
                                      val))
                                nil)))
             do (setf (gethash new-key profiled) outcome))
    (let ((res))
      (maphash (lambda (k v) (push (cons k v) res)) profiled)
      res)))

;;; Keeps track of the number of dispatchers that were compiled and
;;;   is used to give the roots array in each dispatcher a unique name.
(defparameter *dispatcher-count* 0)
(defun codegen-dispatcher (generic-function &key generic-function-name output-path log-gf)
  (let* ((*log-gf* log-gf)
         (raw-call-history (clos:generic-function-call-history generic-function))
         (call-history (optimized-call-history generic-function))
         (dtree (let ((dt (make-dtree)))
                  (cond
                    (call-history
                     (dtree-add-call-history dt call-history))
                    ;; If there is no call-history but there is a raw-call-history then
                    ;; the outcome of every entry should be the same because there are no
                    ;; specializers - so build a dispatch function that calls ignores
                    ;; all arguments and immediately calls the first effective method.
                    (raw-call-history
                     (dtree-add-call-history dt (list (cons #() (cdr (car raw-call-history))))))
                    (t (error "codegen-dispatcher was called with an empty call-history - no dispatcher can be generated")))
                  dt))
         (*the-module* (create-run-time-module-for-compile)))
    #+(or)(unless call-history
            (core:bformat t "codegen-dispatcher %s  optimized-call-history -> %s\n" generic-function-name call-history)
            (core:bformat t "  raw-call-history -> %s\n" raw-call-history)
            (core:bformat t "  specializer-profile -> %s\n" specializer-profile))
    (with-module (:module *the-module*
                  :optimize nil
                  :source-namestring "dispatcher"
                  :source-file-info-handle 0)
      (let* ((dispatcher-name (jit-function-name generic-function-name))
             (disp-fn (irc-simple-function-create dispatcher-name
                                                  %fn-gf%
                                                  'llvm-sys::External-linkage
                                                  *the-module*
                                                  :argument-names %fn-gf-arguments% )))
	;;(1) Create a function with a gf-function signature
	;;(2) Allocate space for a va_list and copy the va_list passed into it.
	;;(3) compile the dispatch function to llvm-ir refering to the eql specializers and stamps and
	;;      the va_list passed.
	;;(4) Reach an outcome and either call the effective method with the saved va_list
	;;      or call the miss function with the saved va_list
	(let* ((irbuilder-alloca (llvm-sys:make-irbuilder *llvm-context*))
	       (irbuilder-body (llvm-sys:make-irbuilder *llvm-context*))
	       (*irbuilder-function-alloca* irbuilder-alloca)
	       (*irbuilder-function-body* irbuilder-body)
	       (*current-function* disp-fn)
               (*gf-data* 
                 (llvm-sys:make-global-variable *the-module*
                                                cmp:%t*[DUMMY]% ; type
                                                nil ; isConstant
                                                'llvm-sys:internal-linkage
                                                (llvm-sys:undef-value-get cmp:%t*[DUMMY]%)
                                                ;; nil ; initializer
                                                (next-value-table-holder-name "dummy")))
               (*gcroots-in-module* 
                 (llvm-sys:make-global-variable *the-module*
                                                cmp:%gcroots-in-module% ; type
                                                nil ; isConstant
                                                'llvm-sys:internal-linkage
                                                (llvm-sys:undef-value-get cmp:%gcroots-in-module%)
                                                ;; nil ; initializer
                                                "GCRootsHolder"))
	       (*gf-data-id* 0)
	       (*message-counter* 0)
	       (*eql-selectors* (make-hash-table :test #'eql))
	       (*outcomes* (make-hash-table))
	       (entry-bb (irc-basic-block-create "entry" disp-fn))
	       (*bad-tag-bb* (irc-basic-block-create "bad-tag" disp-fn))
	       (arguments (llvm-sys:get-argument-list disp-fn))
	       (gf (first arguments))
	       (passed-args (second arguments)))
	  (cmp:irc-set-insert-point-basic-block entry-bb irbuilder-alloca)
	  (let ((body-bb (irc-basic-block-create "body" disp-fn))
		(miss-bb (irc-basic-block-create "miss" disp-fn)))
	    (setf (gethash :miss *outcomes*) miss-bb)
	    (irc-set-insert-point-basic-block body-bb irbuilder-body)
	    ;; Setup exception handling and cleanup landing pad
	    (with-irbuilder (irbuilder-alloca)
	      (let* ((in-frame-va_list/va_list*              (irc-alloca-va_list :label "in-frame-va_list/va_list*"))
                     (arguments                     (make-argument-holder :va-list in-frame-va_list/va_list*
                                                                          :gf-args passed-args
                                                                          :gf gf))
                     (passed-args-tagged/uintptr_t  (irc-ptr-to-int passed-args %uintptr_t% "passed-args-tagged/uintptr_t"))
                     (passed-args-va_list/uintptr_t (irc-add passed-args-tagged/uintptr_t (jit-constant-intptr_t (- +vaslist-valist-offset+ +vaslist-tag+)) "passed-args-va_list/uintptr_t"))
                     (passed-args-va_list/va_list*           (irc-int-to-ptr passed-args-va_list/uintptr_t %va_list*% "passed-args-va_list/va_list*"))
                     (_                             (insert-message))
                     (_                             (debug-arglist (irc-ptr-to-int passed-args %uintptr_t%)))
                     (_                             (irc-intrinsic-call "llvm.va_copy" (list (irc-pointer-cast in-frame-va_list/va_list* %i8*% "in-frame-va_list/i8*")
                                                                                             (irc-pointer-cast passed-args-va_list/va_list* %i8*% "passed-args-va_list/i8*"))))
                     (_                             (insert-message))
                     (_                             (debug-va_list (irc-ptr-to-int in-frame-va_list/va_list* %uintptr_t%)))
                     (_                             (irc-br body-bb)))
		(with-irbuilder (irbuilder-body)
		  (codegen-node-or-outcome arguments (dtree-root dtree)))
		(irc-begin-block *bad-tag-bb*)
		(irc-intrinsic-call "llvm.va_end" (list (irc-pointer-cast in-frame-va_list/va_list* %i8*% "in-frame-va_list/i8*")))
		(irc-intrinsic-call "cc_bad_tag" (list gf passed-args))
		(irc-unreachable)
		(irc-begin-block miss-bb)
		(irc-intrinsic-call "llvm.va_end" (list (irc-pointer-cast in-frame-va_list/va_list* %i8*% "in-frame-va_list/i8*")))
		(irc-ret (irc-intrinsic-call "cc_dispatch_miss" (list gf passed-args) "ret")))))
          (let* ((array-type (llvm-sys:array-type-get cmp:%t*% *gf-data-id*))
		 (correct-size-holder (llvm-sys:make-global-variable *the-module*
								     array-type
								     nil ; isConstant
								     'llvm-sys:internal-linkage
								     (llvm-sys:undef-value-get array-type)
								     (bformat nil "CONSTANTS-%d" (incf *dispatcher-count*))))
		 (bitcast-correct-size-holder (irc-bit-cast correct-size-holder %t*[DUMMY]*% "bitcast-table")))
            (multiple-value-bind (startup-fn shutdown-fn)
                (codegen-startup-shutdown *gcroots-in-module* correct-size-holder *gf-data-id*)
              (llvm-sys:replace-all-uses-with *gf-data* bitcast-correct-size-holder)
              (llvm-sys:erase-from-parent *gf-data*)
              #+debug-cmpgf(progn
                             (core:bformat t "Dumping the module from codegen-dispatcher\n")
                             (llvm-sys:dump-module *the-module*))
              (let ((sorted-roots (gather-sorted-outcomes *eql-selectors* *outcomes*)))
                ;; REMOVE THE FOLLOWING IN PRODUCTION CODE
                #||                #+debug-cmpgf
                (progn
                (let ((before-disp-name (llvm-sys:get-name disp-fn)))
                (debug-save-dispatcher the-gf *the-module* disp-fn startup-fn shutdown-fn sorted-roots)
                (let ((after-disp-name (llvm-sys:get-name disp-fn)))
                (format t "Saved dispatcher  before-disp-name -> ~a     after-disp-name -> ~a~%" before-disp-name after-disp-name))))
                ||#
                (when output-path
                  (debug-save-dispatcher generic-function *the-module* disp-fn startup-fn shutdown-fn sorted-roots output-path))
                (let* ((compiled-dispatcher (jit-add-module-return-dispatch-function *the-module* disp-fn startup-fn shutdown-fn sorted-roots)))
                  compiled-dispatcher)))))))))

(export '(make-dtree
	  dtree-add-call-history
	  draw-graph
	  codegen-dispatcher))



(defun disassemble-fastgf (generic-function)
  (if (clos:generic-function-call-history generic-function)
      (let* ((*save-module-for-disassemble* t)
             (*saved-module-from-clasp-jit* nil))
        (let ((dispatcher (codegen-dispatcher generic-function :generic-function-name 'disassemble))
              (module cmp:*saved-module-from-clasp-jit*))
          (if module
              (llvm-sys:dump-module module)
              (core:bformat t "Could not obtain module for disassemble of generic-function %s dispatcher -> %s\n" generic-function dispatcher))))
      (core:bformat t "The dispatcher cannot be built because there is no call history\n")))

(defun generate-dot-file (generic-function output)
  (let* ((call-history (optimized-call-history generic-function))
         (dispatch-tree (let ((dt (make-dtree)))
                          (dtree-add-call-history dt call-history)
                          dt)))
    (cmp::draw-graph (namestring output) dispatch-tree)))

(defun graph-fastgf-dispatch-function (generic-function)
  (generate-dot-file generic-function "/tmp/dispatch.dot")
  (ext:system "/usr/local/bin/dot -Tpdf -o /tmp/dispatch.pdf /tmp/dispatch.dot")
  (sleep 0.2)
  (ext:system "open /tmp/dispatch.pdf"))
  

(export '(generate-dot-file graph-fastgf-dispatch-function disassemble-fastgf))

