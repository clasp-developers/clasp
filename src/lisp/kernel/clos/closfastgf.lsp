;;; ------------------------------------------------------------
;;;
;;; Generic function dispatch compiler
;;;   This implements the algorithm described by Robert Strandh for fast generic function dispatch
;;;
;;;   clos:generic-function-call-history is an alist of (past-call-signature . effective-method-closure)
;;;      The effective-method-closure is generated by combin.lsp:combine-method-functions3 and
;;;        the fptr always points to combin.lsp:combine-method-functions3.lambda
;;;        and is closed over the method and the rest-methods.
;;;      The past-call-signature is a simple-vector of classes for class-specializers
;;;        or (list eql-spec) for eql specializers.  The CAR of eql-spec is the EQL value and the
;;;        argument passed to the generic function.
;;;        eql-spec is the result of calling spec_type.unsafe_cons()->memberEql(spec_position_arg)
;;;          in the function fill_spec_vector.
;;;          https://github.com/drmeister/clasp/blob/dev/src/core/genericFunction.cc#L194
;;;

(in-package :clos)

;;; ------------------------------------------------------------
;;;
;;; Debugging code
;;;
;;; Add :LOG-CMPGF to log fastgf messages during the slow path.
;;;
#+(or)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (pushnew :debug-fastgf *features*))


#+debug-fastgf
(eval-when (:execute :load-toplevel)
  (defstruct (debug-fastgf-struct (:type vector))
    stream
    didx
    indent
    miss-count)
  (defvar *dmspaces* "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ")
;;; Cleanup up the directory

  (defvar *dispatch-history-dir*
    (let ((dir (core:bformat nil "/tmp/dispatch-history-%d/" (core:getpid))))
      (ensure-directories-exist dir)
      (core:bformat *error-output* "!!!!  Created gf dispatch monitor directory: %s%N" dir)
      (core:bformat *error-output* "!!!!     Run clasp with --feature fastgf-dump-module to write dispatchers to this directory%N")
      (dolist (f (directory (core:bformat nil "%s/*.*" dir)))
        (delete-file f))
      dir))
  (defun lazy-initialize-debug-fastgf ()
    (unless core:*debug-fastgf*
      (let ((filename (core:bformat nil "%s/debug-miss-thread%s.log"
                                    *dispatch-history-dir*
                                    (core:pointer-as-string (mp:thread-id mp:*current-process*)))))
        (setf core:*debug-fastgf* (make-debug-fastgf-struct :stream (open filename :direction :output)
                                                            :didx 0
                                                            :indent 0
                                                            :miss-count (make-hash-table))))))
  (defun debug-fastgf-stream ()
    (lazy-initialize-debug-fastgf)
    (debug-fastgf-struct-stream core:*debug-fastgf*))
 
  (defun debug-fastgf-didx ()
    (lazy-initialize-debug-fastgf)
    (debug-fastgf-struct-didx core:*debug-fastgf*))
  (defun incf-debug-fastgf-didx ()
    (incf (debug-fastgf-struct-didx core:*debug-fastgf*)))
  
  (defun debug-fastgf-miss-count (gf)
    (gethash gf (debug-fastgf-struct-miss-count core:*debug-fastgf*) 0))
  (defun incf-debug-fastgf-miss-count (gf)
    (lazy-initialize-debug-fastgf)
    (incf (gethash gf (debug-fastgf-struct-miss-count core:*debug-fastgf*) 0)))
    
  (defun debug-fastgf-indent ()
    (debug-fastgf-struct-indent core:*debug-fastgf*))
  (defun incf-debug-fastgf-indent ()
    (lazy-initialize-debug-fastgf)
    (incf (debug-fastgf-struct-indent core:*debug-fastgf*) 2))
  (defun decf-debug-fastgf-indent ()
    (decf (debug-fastgf-struct-indent core:*debug-fastgf*) 2))
  (defmacro bformat-noindent (fmt &rest args)
    `(progn
       (lazy-initialize-debug-fastgf)
       (core:bformat (debug-fastgf-stream) ,fmt ,@args)))
  (defmacro bformat-indent (fmt &rest args)
    `(progn
       (lazy-initialize-debug-fastgf)
       (core:bformat (debug-fastgf-stream) (subseq *dmspaces* 0 (min (length *dmspaces*) (debug-fastgf-indent))))
       (core:bformat (debug-fastgf-stream) ,fmt ,@args)))
  (defun graph-call-history (generic-function output)
    (cmp:generate-dot-file generic-function output))
  (defun log-cmpgf-filename (gfname suffix extension)
    (pathname (core:bformat nil "%s/dispatch-thread%s-%s%05d-%s.%s"
                            *dispatch-history-dir*
                            (pointer-as-string (mp:thread-id mp:*current-process*))
                            suffix
                            (debug-fastgf-didx)
                            (core:bformat nil "%s" gfname)
                            extension)))
  (defmacro gf-log-dispatch-graph (gf)
    `(graph-call-history ,gf (log-cmpgf-filename (clos::generic-function-name gf) "graph" "dot")))
  (defmacro gf-log-dispatch-miss-followup (msg &rest args)
    `(progn
       (bformat-indent "------- ")
       (bformat-noindent ,msg ,@args)))
  (defmacro gf-log-dispatch-miss-message (msg &rest args)
    `(bformat-indent ,msg ,@args))
  (defmacro gf-log-sorted-roots (roots)
    `(progn
       (bformat-indent ">>> sorted roots%N")
       (let ((x 0))
         (mapc (lambda (root)
                 (bformat-indent "  root[%d]: %s%N" (prog1 x (incf x)) root))))))
  (defun pretty-selector-as-string (selector)
    (cond
      ((consp selector)
       (core:bformat nil "(EQL %s)" (car selector))) ; for EQL specializer
      ((null selector)
       (core:bformat nil "NULL/(not-specialized?)"))
      ((classp selector)               ; A class
       (core:bformat nil "[class %s/%d]" (class-name selector) (core:class-stamp-for-instances selector)))
      (t                                ; This shouldn't happen
       (core:bformat nil "!!!!!ILLEGAL-SELECTOR-IN-CALL-HISTORY-ENTRY-KEY!!!!!"))))
  (defmacro gf-print-entry (index entry)
    (let ((selector (gensym))
          (key (gensym)))
      `(progn
         (bformat-indent "        entry#%3d: (" (prog1 ,index (incf ,index)))
         (let ((,key (car ,entry)))
           ;;(bformat-indent "          ----> %s%N" history-entry)
           (dolist (,selector (coerce ,key 'list))
             (bformat-noindent " %s" (pretty-selector-as-string ,selector)))
           (bformat-noindent ")%N")))))
  (defmacro gf-log-dispatch-miss (msg gf va-args)
    `(progn
       (incf-debug-fastgf-didx)
       (incf-debug-fastgf-miss-count ,gf)
       (bformat-indent "------- DIDX:%d %s%N" (debug-fastgf-didx) ,msg)
       (bformat-indent "Dispatch miss #%d for %s%N" (debug-fastgf-miss-count ,gf) (clos::generic-function-name ,gf))
       (let* ((args-as-list (core:list-from-va-list ,va-args))
              (call-history (clos::generic-function-call-history ,gf))
              (specializer-profile (clos::generic-function-specializer-profile ,gf)))
         (bformat-indent "    args (num args -> %d):  %N" (length args-as-list))
         (let ((arg-index -1))
           (dolist (arg args-as-list)
             (bformat-indent "argument# %d: %s[%s/%d] %N" (incf arg-index) arg (class-of arg) (core:instance-stamp arg))))
         (let ((index 0))
           (bformat-indent " raw call-history (length -> %d):%N" (length call-history))
           (dolist (entry call-history)
             (gf-print-entry index entry)))
         (let* ((call-history (generic-function-call-history generic-function))
                (specializer-profile (generic-function-specializer-profile generic-function))
                (optimized-call-history (cmp::optimized-call-history call-history specializer-profile))
                (index 0))
           (bformat-indent "    optimized call-history (length -> %d):%N" (length optimized-call-history))
           (dolist (entry optimized-call-history)
             (gf-print-entry index entry))))
       (finish-output (debug-fastgf-stream))))
  (defmacro gf-log (fmt &rest fmt-args) `(bformat-indent ,fmt ,@fmt-args))
  (defmacro gf-log-noindent (fmt &rest fmt-args) `(bformat-noindent ,fmt ,@fmt-args))
  (defmacro gf-do (&body code) `(progn ,@code)))

#-debug-fastgf
(eval-when (:execute :load-toplevel)
  (defmacro gf-log-sorted-roots (roots) nil)
  (defmacro gf-log-dispatch-graph (gf) nil)
  (defmacro gf-log-dispatch-miss (msg gf va-args) nil)
  (defmacro gf-log-dispatch-miss-followup (msg &rest args) nil)
  (defmacro gf-log-dispatch-miss-message (msg &rest args) nil)
  (defmacro gf-log (fmt &rest fmt-args) nil)
  (defmacro gf-log-noindent (fmt &rest fmt-args) nil)
  (defmacro gf-do (&body code) nil)
  (defun incf-debug-fastgf-indent ())
  (defun decf-debug-fastgf-indent ())
  )
  


;;; --------------------------------------------------
;;;
;;; This section contains code that is called by CLOS to
;;;   update generic-function-call-history and to call
;;;   codegen-dispatcher to generate a new dispatch function when needed
;;;

;;; Called from cc_bound_or_error -> intrinsic_slot_unbound
(defun fastgf-slot-unbound (opt-slot-reader instance)
  (slot-unbound (cmp::optimized-slot-reader-class opt-slot-reader)
                instance
                (cmp::optimized-slot-reader-slot-name opt-slot-reader)))

;;; Takes three arguments ((x cmp::optimized-slot-reader) instance vargs)
(defun dispatch-slot-reader-index-debug (opt-slot-reader instance vargs)
  ;; Do the slot read and check against the slot index
  (let ((opt-method (cmp::optimized-slot-reader-method opt-slot-reader))
        (opt-class (cmp::optimized-slot-reader-class opt-slot-reader))
        (slot-name (cmp::optimized-slot-reader-slot-name opt-slot-reader))
        (opt-index (cmp::optimized-slot-reader-index opt-slot-reader)))
    (let* ((slot (effective-slotd-from-accessor-method opt-method opt-class))
           (lookup-index (slot-definition-location slot)))
      (unless (= opt-index lookup-index)
        (error "The dispatch-slot-reader-index-debug function caught a difference between the slot opt-index ~a and the looked up slot index ~a for opt-method ~a/ opt-class ~a/ slot-name ~a" opt-index lookup-index opt-method opt-class slot-name))
      (let ((direct-result (core:instance-ref instance opt-index))
            (efm-result (funcall (cmp::optimized-slot-reader-effective-method-function opt-slot-reader) vargs nil)))
        (unless (eql direct-result efm-result)
          ;; Do what std-class-optimized-accessors does...
          (let* ((efm-class (si:instance-class instance))
                 (efm-table (class-location-table efm-class))
                 (efm-index (gethash slot-name efm-table))
                 (efm-value (if (si::fixnump efm-index)
                                (si:instance-ref instance (the fixnum efm-index))
                                (car (the cons efm-index)))))
            (format *error-output* "DATA FOR READER ERROR!!!!!!!!!!!!!!!!!!!!!~%")
            (format *error-output* "slot-name -----> ~s~%" slot-name)
            (format *error-output* "opt-index -----> ~s~%" opt-index)
            (format *error-output* "opt-method ----> ~s~%" opt-method)
            (format *error-output* "opt-class -----> ~s~%" opt-class)
            (format *error-output* "(core:instance-stamp instance) --------------------------------------------> ~s~%" (core:instance-stamp instance))
            (format *error-output* "(core:lookup-class-with-stamp (core:instance-stamp instance)) -------------> ~s~%" (core:lookup-class-with-stamp (core:instance-stamp instance)))
            (format *error-output* "(core:class-stamp-for-instances opt-class) --------------------------------> ~s~%" (core:class-stamp-for-instances opt-class))
            (format *error-output* "(core:lookup-class-with-stamp (core:class-stamp-for-instances opt-class)) -> ~s~%" (core:lookup-class-with-stamp (core:class-stamp-for-instances opt-class)))
            (format *error-output* "efm-class -----> ~s~%" efm-class)
            (format *error-output* "efm-index -----> ~s~%" efm-index)
            (format *error-output* "efm-value -----> ~s~%" efm-value)
            (format *error-output* "(core::object-address instance) -> ~s~%" (core::object-address instance))
            (error "The dispatch-slot-reader-index-debug function caught a difference between reading the slot and calling the effective-method-function")))
        efm-result))))

;;; Takes four arguments ((x cmp::optimized-slot-writer) value instance vargs)
(defun dispatch-slot-writer-index-debug (opt-slot-writer value instance vargs)
  ;; Check against the slot index and Do the slot write and check against the slot index
  (let ((opt-method (cmp::optimized-slot-writer-method opt-slot-writer))
        (class (cmp::optimized-slot-writer-class opt-slot-writer))
        (slot-name (cmp::optimized-slot-writer-slot-name opt-slot-writer))
        (opt-index (cmp::optimized-slot-writer-index opt-slot-writer)))
    (let* ((slot (effective-slotd-from-accessor-method opt-method class))
           (lookup-index (slot-definition-location slot)))
      (unless (= opt-index lookup-index)
        (error "The dispatch-slot-writer-index-debug function caught a difference between the optimized slot index ~a and the looked up slot index ~a for opt-method ~a/ class ~a/ slot-name ~a" opt-index lookup-index opt-method class slot-name))
      (let ((efm-result (funcall (cmp::optimized-slot-writer-effective-method-function opt-slot-writer) vargs nil))
            (after-write-read (core:instance-ref instance opt-index)))
        (unless (eql efm-result after-write-read)
          (let ((*print-circle* nil))
            (error "The dispatch-slot-writer-index-debug function caught a difference between what should be in the slot opt-index ~a~% (read value -> ~s)~% after writing ~s into it using the effective-method-function.~% This is for opt-method ~s/class ~s/slot-name ~s~% and (core:class-stamp-for-instances class) -> ~s    (core:instance-stamp instance) -> ~s~%  (core:object-address instance) -> ~s~%" 
                   opt-index after-write-read efm-result opt-method class slot-name (core:class-stamp-for-instances class) (core:instance-stamp instance) (core:object-address instance))))
        efm-result))))

(defun maybe-update-instances (arguments)
  (let ((invalid-instance nil))
    (dolist (x arguments)
      (when (core:instancep x)
        (let* ((i x)
               (s (si::instance-sig i)))
          (clos::with-early-accessors (clos::+standard-class-slots+)
            (when (si::sl-boundp s)
              (unless (= (core:instance-stamp i) (core:class-stamp-for-instances (core:instance-class i)))
                (gf-log "   instance-stamp matches that of class -> %s%N"  (= (core:instance-stamp i) (core:class-stamp-for-instances (core:instance-class i))))
                (gf-log "(core:instance-stamp i) -> %s%N" (core:instance-stamp i))
                (gf-log "(core:class-stamp-for-instances (core:instance-class i)) -> %s%N" (core:class-stamp-for-instances (core:instance-class i)))
                (setf invalid-instance t)
                (clos::update-instance i)
                (core:instance-stamp-set i (core:class-stamp-for-instances (si:instance-class i)))))))))
    invalid-instance))

;; A call history selector a list of classes and eql-specializers
;; So to compute the applicable methods we need to consider the following cases for each
;; possible entry selector ...
;; 1) The selector is a list of just classes
;;      In that case behavior like that of compute-applicable-methods-using-classes can be used
;; 2) The selector is a mix of classes and eql-specializers
;;      In this case something like compute-applicable-methods needs to be used - but
;;         compute-applicable-methods takes a list of ARGUMENTS
;;        So I think we 
(defun applicable-method-p (method specializers)
  (loop for spec in (method-specializers method)
     for argspec in specializers
     always (if (eql-specializer-flag spec)
                (and (consp argspec) (eql (car argspec) (eql-specializer-object spec)))
                (if (consp argspec) ; eql specializer?
                    (subclassp (class-of argspec) spec)
                    (subclassp argspec spec)))))

(defun applicable-method-list-using-specializers (gf specializers)
  (declare (optimize (speed 3)))
  (with-early-accessors (+standard-method-slots+
			 +standard-generic-function-slots+
			 +eql-specializer-slots+
			 +standard-class-slots+)
    (loop for method in (generic-function-methods gf)
       when (applicable-method-p method specializers)
       collect method)))

(defun compute-applicable-methods-using-specializers (generic-function specializers)
  (check-type specializers list)
  (sort-applicable-methods generic-function
                           (applicable-method-list-using-specializers generic-function specializers)
                           (mapcar (lambda (s) (if (consp s)
                                                   (class-of (car s))
                                                   s))
                                   specializers)))

(defun effective-slotd-from-accessor-method (method class)
  (let* ((direct-slot (accessor-method-slot-definition method))
         (direct-slot-name (slot-definition-name direct-slot))
         (effective-slot-defs (class-slots class))
         (slot (loop for effective-slot in effective-slot-defs
                     when (eq direct-slot-name (slot-definition-name effective-slot)) return effective-slot)))
    (when (null slot) ; should be impossible. one way I hit it: abnormal slots from boot.lsp
      (error "BUG: cannot find effective slot for optimized accessor! class ~s, slot name ~s"
             class direct-slot-name))
    slot))

;; We try to reuse effective method functions when possible.
;; This has two advantages: One, we avoid recompiling the same effective method multiple times.
;; Two, the code generator can understand the outcomes as identical and merge tests together.
;; Note that this being correct relies on an important property: that compute-effective-method
;; can in fact be memoized. This would not be the case if for example a method on it returns
;; different things for the same (by EQUAL) applicable method lists randomly or by time, or if
;; a relevant compute-effective-method method is added after a generic function already has
;; computed some. Or if a method combination does something similarly weird.
;; I'm not really worried about this because nobody defines methods on c-e-m anyway.
;; Also, this is a max O(mn) search, where m is the number of methods and n the length of call
;; history. It could be more efficient, but that makes it more involved to remove old entries
;; (with this scheme they're just removed with the call history entries).
(defun find-existing-emf (call-history methods)
  (loop for (ignore . outcome) in call-history
        when (and (cmp::effective-method-outcome-p outcome)
                  (equal methods (cmp::effective-method-outcome-applicable-methods outcome)))
          return outcome))

(defun compute-outcome
    (generic-function method-combination methods actual-specializers &key log actual-arguments)
  ;; Calculate the effective-method-function as well as an optimized one
  ;; so that we can apply the e-m-f to the arguments if we need to debug the optimized version.
  ;; This will hopefully be expanded, but for now, we can at least optimize standard slot accesses.
  ;; For that, we must determine whether there is not a custom slot-value-using-class method we have to
  ;; call. We use an approximation: if the class is a standard-class and the slotd is a
  ;; standard-effective-slot-definition, methods on svuc can't be defined per
  ;; "restrictions on portable programs" in MOP. We also discount the possibility of specializing on the
  ;; "object" argument, because it makes things harder for us with not much gain for users.
  ;; (Just specialize accessors or something.)
  ;; The upshot of this is that slot accesses will never be inlined for custom metaclasses or slotds.
  ;; The less approximate way would be to check s-v-u-c itself. That's easy enough on its own,
  ;; but also implies that methods added or removed to s-v-u-c invalidate all relevant accessors,
  ;; which is not.
  (when (null methods)
    ;; no-applicable-method is different from the no-required-method we'd get if we went below,
    ;; so we pick that off first.
    ;; Similarly to nrm below, we return a sort of fake emf.
    (return-from compute-outcome
      (cmp::make-function-outcome
       :function
       (lambda (vaslist-args ignore)
         (declare (ignore ignore))
         (apply #'no-applicable-method generic-function vaslist-args)))))
  (let* ((em (compute-effective-method generic-function method-combination methods))
         (method (and (consp em)
                      (eq (first em) 'call-method)
                      (second em)))
         (leafp (when method (leaf-method-p method)))
         (fmf (when leafp (fast-method-function method)))
         ;; In the future, we could use load-time-value instead of find-class every time,
         ;; but the system loading architecture makes this dicey at the moment.
         (readerp (when method (eq (class-of method) (find-class 'standard-reader-method))))
         (writerp (when method (eq (class-of method) (find-class 'standard-writer-method))))
         (class (cond ((not method) nil)
                      (readerp (first actual-specializers))
                      (writerp (second actual-specializers))
                      (t nil)))
         (slotd (when class (effective-slotd-from-accessor-method method class)))
         (standard-slotd-p (when slotd (eq (class-of slotd) (find-class 'standard-effective-slot-definition))))
         ;; When there is no applicable method in a required group (e.g. qualifier-less methods, for standard mc)
         ;; the effective method will be a call to no-required-method. See combin.lsp.
         ;; the SECOND is because the symbol is quoted.
         (nrm-group-name (and (consp em) (eq (first em) 'no-required-method) (second (third em))))
         existing-emf
         (optimized
           (cond ((not standard-slotd-p)
                  (cond (fmf
                         (gf-log "Using fast method %s function as emf%N" method)
                         (cmp::make-fast-method-call :function fmf))
                        (leafp
                         (gf-log "Using method %s function as emf%N" method)
                         (cmp::make-function-outcome :function (method-function method)))
                        (nrm-group-name ; missing a required (probably primary) method.
                         ;; FIXME: this is kind of ugly, to say the least. inlining would be nice.
                         (cmp::make-function-outcome
                          :function
                          (lambda (vaslist-args ignore)
                            (declare (ignore ignore))
                            (apply #'no-required-method generic-function nrm-group-name vaslist-args))))
                        ((setf existing-emf (find-existing-emf (generic-function-call-history generic-function)
                                                               methods))
                         (gf-log "Using existing effective method function%N")
                         existing-emf)
                        (t
                         (gf-log "Using default effective method function%N")
                         (gf-log "(compute-effective-method generic-function method-combination methods) -> %N")
                         (gf-log "%s%N" em)
                         (cmp::make-effective-method-outcome
                          :applicable-methods methods
                          :function (effective-method-function em)))))
                 (readerp
                  (gf-log "make-optimized-slot-reader index: %s slot-name: %s class: %s%N"
                          (slot-definition-location slotd)
                          (slot-definition-name slotd)
                          class)
                  (cmp::make-optimized-slot-reader :index (slot-definition-location slotd)
                                                   :slot-name (slot-definition-name slotd)
                                                   :method method :class class))
                 (writerp
                  (gf-log "make-optimized-slot-writer index: %s slot-name: %s class: %s%N"
                          (slot-definition-location slotd)
                          (slot-definition-name slotd)
                          class)
                  (cmp::make-optimized-slot-writer :index (slot-definition-location slotd)
                                                   :slot-name (slot-definition-name slotd)
                                                   :method method :class class))
                 ;; I think these are unreachable, but better safe than sorry.
                 ((setf existing-emf (find-existing-emf (generic-function-call-history generic-function)
                                                        methods))
                  (gf-log "Using !SUPPOSEDLY UNREACHABLE! existing effective method function%N")
                  existing-emf)
                 (t
                  (gf-log "Using !SUPPOSEDLY UNREACHABLE! default effective method function%N")
                  (gf-log "(compute-effective-method generic-function method-combination methods) -> %N")
                  (gf-log "%s%N" em)
                  (cmp::make-effective-method-outcome
                   :applicable-methods methods
                   :function (effective-method-function em))))))
    #+debug-fastgf
    (when log
      (gf-log "vvv************************vvv%N")
      (gf-log "compute-effective-method-function for %s%N" (generic-function-name generic-function))
      (gf-log "There are %d methods...%N" (length methods))
      (dolist (m methods)
        (gf-log "Method: %s %s %s%N" (clos::method-specializers m) (clos::method-qualifiers m) m))
      (gf-log "Effective method function -> %s%N" optimized)
      (gf-log "Effective method function address -> %s%N" (core:object-address optimized))
      (gf-log "^^^************************^^^%N"))
    optimized))

(defun update-call-history-for-add-method (generic-function orig-call-history method)
  "When a method is added then we update the effective-method-functions for
   those call-history entries with specializers that the method would apply to."
  (let ((call-history (copy-list orig-call-history)))
    (loop for entry in call-history
       for specializers = (coerce (car entry) 'list)
       when (applicable-method-p method specializers)
       do (let* ((methods (compute-applicable-methods-using-specializers
                           generic-function
                           specializers))
                 (outcome (compute-outcome
                           generic-function
                           (generic-function-method-combination generic-function)
                           methods
                           specializers)))    ;;; I have actual specializers from the call history in specializers
            (rplacd entry outcome)))
    call-history))

(defun update-generic-function-call-history-for-add-method (generic-function method)
  "When a method is added then we update the effective-method-functions for
   those call-history entries with specializers that the method would apply to.
FIXME!!!! This code will have problems with multithreading if a generic function is in flight. "
  (loop for call-history = (generic-function-call-history generic-function)
     for new-call-history = (update-call-history-for-add-method generic-function call-history method)
     for exchange = (generic-function-call-history-compare-exchange generic-function call-history new-call-history)
     until (eq exchange new-call-history)))

(defun update-call-history-for-remove-method (generic-function call-history method)
  (let (new-call-history)
    (loop for entry in call-history
       for specializers = (coerce (car entry) 'list)
       if (applicable-method-p method specializers)
       do (let* ((methods (compute-applicable-methods-using-specializers
                           generic-function
                           specializers))
                 (outcome (if methods
                              (compute-outcome
                               generic-function
                               (generic-function-method-combination generic-function)
                               methods
                               specializers) ;; I have the actual specializers in specializers
                              nil)))
            (when outcome
              (push (cons (car entry) outcome) new-call-history)))
       else
       do (push (cons (car entry) (cdr entry)) new-call-history))
    new-call-history))

(defun update-generic-function-call-history-for-remove-method (generic-function method)
  "When a method is removed then we update the effective-method-functions for
   those call-history entries with specializers that the method would apply to
    AND if that means there are no methods left that apply to the specializers
     then remove the entry from the list.
FIXME!!!! This code will have problems with multithreading if a generic function is in flight. "
  (loop for call-history = (generic-function-call-history generic-function)
     for new-call-history = (update-call-history-for-remove-method generic-function call-history method)
     for exchange = (generic-function-call-history-compare-exchange generic-function call-history new-call-history)
     until (eq exchange new-call-history)))

(defun erase-generic-function-call-history (generic-function)
  (loop for call-history = (generic-function-call-history generic-function)
     for new-call-history = nil
     for exchange = (generic-function-call-history-compare-exchange generic-function call-history new-call-history)
        until (eq exchange new-call-history)))

(defun specializer-key-match (key1 key2)
  (declare (type simple-vector key1 key2))
  ;; Keys are simple vectors of "specializers" where a "specializer" is either a class, or (cons object nil),
  ;; this latter representing an eql specializer.
  ;; We want to compare the former by eq and the latter by eql of the car.
  (loop for s1 across key1 for s2 across key2
        always (if (consp s1) ; eql specializer
                   (if (consp s2)
                       (eql (car s1) (car s2))
                       ;; one is an eql specializer, the other is a class
                       nil)
                   ;; s1 is a class, so s2 must be an eq class
                   (eq s1 s2))))

(defun call-history-find-key (call-history memoized-key)
  "Return true if the given key is already present in the history, or else nil."
  (loop for (key . ignore) in call-history
        when (specializer-key-match key memoized-key) do (return-from call-history-find-key t))
  nil)

(defun memoize-call (generic-function memoized-key effective-method-function)
  "Memoizes the call and installs a new discriminator function - returns nothing"
  (gf-log "Specializers key: %s%N" memoized-key)
  (gf-log "The specializer-profile: %s%N" (generic-function-specializer-profile generic-function))
  (let ((specializer-profile (generic-function-specializer-profile generic-function)))
    (unless (= (length memoized-key) (length specializer-profile))
      (error "The memoized-key ~a is not the same length as the specializer-profile ~a for ~a" memoized-key specializer-profile generic-function))
    (loop for call-history = (generic-function-call-history generic-function)
          for found-key = (call-history-find-key call-history memoized-key)
          for new-call-history = (if found-key
                                     (progn
                                       (gf-log "For generic function: %s - the key was already in the history - either bad dtree, incorrect lowering to llvm-ir or maybe (unlikely) put there by another thread.%N"
                                               (generic-function-name generic-function))
                                       call-history)
                                     (progn
                                       (gf-log "Pushing entry into call history%N")
                                       (cons (cons memoized-key effective-method-function) call-history)))
          for exchanged = (generic-function-call-history-compare-exchange generic-function call-history new-call-history)
          do (progn
               #+debug-fastgf(let ((specializer-profile (clos:generic-function-specializer-profile generic-function)))
                               (when call-history
                                 (gf-log "The dtree calculated for the call-history/specializer-profile:%N")
                                 (gf-log "%s%N" (cmp::calculate-dtree call-history specializer-profile)))))
          when exchanged do (gf-log "Successfully exchanged call history%N")
            until (eq exchanged new-call-history))
    (loop for idx from 0 below (length memoized-key)
          for specializer = (svref memoized-key idx)
          unless (consp specializer)    ; eql specializer
            do (core:specializer-call-history-generic-functions-push-new specializer generic-function))
    #+debug-long-call-history
    (when (> (length (generic-function-call-history generic-function)) 16384)
      (error "DEBUG-LONG-CALL-HISTORY is triggered - The call history for ~a is longer (~a entries) than 16384" generic-function (length (generic-function-call-history generic-function))))
    (invalidate-discriminating-function generic-function)
    (values)))

(defun perform-outcome (outcome arguments vaslist-arguments)
  (cond
    ((cmp::optimized-slot-reader-p outcome)
     ;; Call is like (name instance)
     (let ((value (standard-instance-access (first arguments) (cmp::optimized-slot-reader-index outcome))))
       (if (si:sl-boundp value)
           value
           (values (slot-unbound (cmp::optimized-slot-reader-class outcome) (first arguments)
                                 (cmp::optimized-slot-reader-slot-name outcome))))))
    ((cmp::optimized-slot-writer-p outcome)
     ;; Call is like ((setf name) new-value instance)
     (setf (standard-instance-access (second arguments) (cmp::optimized-slot-writer-index outcome))
           (first arguments)))
    ((cmp::fast-method-call-p outcome)
     (apply (cmp::fast-method-call-function outcome) arguments))
    ;; Effective method functions take the same arguments as method functions - vasargs and next-methods
    ;; for now, at least. Obviously they don't actually need the next-methods.
    ((cmp::effective-method-outcome-p outcome)
     (funcall (cmp::effective-method-outcome-function outcome) vaslist-arguments nil))
    ((cmp::function-outcome-p outcome)
     (funcall (cmp::function-outcome-function outcome) vaslist-arguments nil))
    (t (error "BUG: Bad thing to be an outcome: ~a" outcome))))

#+debug-fastgf
(defvar *dispatch-miss-start-time*)

(defun all-eql-specialized-p (spec-list arguments)
  ;; Make sure that any argument in a position with eql-specializers is an eql specializer object.
  ;; If they all are, return a memoization key. If not, NIL.
  ;; See comment in do-dispatch-miss for rationale.
  (loop for (spec . ignore) in spec-list
        for arg in arguments
        collect (if (listp spec)
                    (if (member arg spec)
                        (list arg) ; list means eql specializer object.
                        (return-from all-eql-specialized-p nil))
                    (class-of arg))
          into key
        finally (return (coerce key 'simple-vector))))

(defun do-dispatch-miss (generic-function vaslist-arguments arguments)
  "This effectively does what compute-discriminator-function does and maybe memoizes the result 
and calls the effective-method-function that is calculated.
It takes the arguments in two forms, as a vaslist and as a list of arguments."
  (multiple-value-bind (min max) (generic-function-min-max-args generic-function)
    (cond ((< (length arguments) min)
           (error 'simple-program-error
                  :format-control "Not enough arguments when calling ~a - you provided ~d and ~d are required"
                  :format-arguments (list (generic-function-name generic-function)
                                          (length arguments) min)))
          ((and max (> (length arguments) max))
           (error 'simple-program-error
                  :format-control "Too many arguments when calling ~a - you provided ~d and ~d are allowed"
                  :format-arguments (list (generic-function-name generic-function)
                                          (length arguments) max)))))
  (let ((argument-classes (mapcar #'class-of arguments))
        #+debug-fastgf
        (*dispatch-miss-start-time* (get-internal-real-time)))
    ;; FIXME: What if another thread adds/removes method during c-a-m-u-c?
    (multiple-value-bind (method-list ok)
        (compute-applicable-methods-using-classes generic-function argument-classes)
      (declare (core:lambda-name do-dispatch-miss.multiple-value-bind.lambda))
      (gf-log "Called compute-applicable-methods-using-classes - returned method-list: %s  ok: %s%N" method-list ok)
      (let* ((method-list (if ok
                              method-list
                              (compute-applicable-methods generic-function arguments)))
             (outcome (compute-outcome
                       generic-function
                       (generic-function-method-combination generic-function)
                       method-list
                       argument-classes
                       :log t
                       :actual-arguments arguments)))
        ;; Can we memoize the call, i.e. add it to the call history?
        (cond ((null method-list) ; we avoid memoizing no-applicable-methods, as it's probably just a mistake,
               ;; and will just pollute the call history.
               ;; This assumption would be wrong if an application frequently called a gf wrong and relied on
               ;; the signal behavior etc, but I find that possibility unlikely.
               (gf-log-dispatch-miss "No applicable method" generic-function vaslist-arguments))
              (ok ; classes are fine; use normal fastgf
               (gf-log-dispatch-miss "Memoizing normal call" generic-function vaslist-arguments)
               (let ((key-length (length (generic-function-specializer-profile generic-function))))
                 (memoize-call generic-function
                               (coerce (subseq argument-classes 0 key-length) 'simple-vector)
                               outcome)))
              ((eq (class-of generic-function) (find-class 'standard-generic-function))
               ;; we have a call with eql specialized arguments.
               ;; We can still memoize this sometimes, as long as the gf is standard.
               ;; What we need to watch out for it the following situation-
               ;; (defmethod foo ((x (eql 'x))) ...)
               ;; (foo 'y)
               ;; If we memoize this naively, we'll put in an entry for class SYMBOL,
               ;; and then if we call (foo 'x) later, it will go to that instead of properly
               ;; missing the cache.
               ;; EQL specializers play merry hob hell with the assumption of fastgf that
               ;; as long as you treat all classes distinctly there are no problems with inheritance,
               ;; basically.
               ;; So, we only memoize the (foo 'x) call, and leave the more general symbol specialization
               ;; to slow path. We could fix it up further to have that fast-path as well, but I think
               ;; it's more involved, and probably not worth it, as most functions with eql specialization
               ;; only use that argument with eql specializer objects, or so I assume.
               (let ((maybe-memo-key
                       (all-eql-specialized-p (generic-function-spec-list generic-function) arguments)))
                 (cond (maybe-memo-key
                        (gf-log-dispatch-miss "Memoizing eql-specialized call" generic-function vaslist-arguments)
                        (unless (= (length maybe-memo-key) (length (generic-function-specializer-profile generic-function)))
                          (error "In do-dispatch-miss mismatch between (length maybe-memo-key) -> ~a and (length (generic-function-specializer-profile generic-function)) -> ~a for ~a" (length maybe-memo-key) (length (generic-function-specializer-profile generic-function)) generic-function))
                        (memoize-call generic-function maybe-memo-key outcome))
                       (t
                        (gf-log-dispatch-miss "Cannot memoize eql-specialized call"
                                              generic-function vaslist-arguments)))))
              (t
               ;; No more options: we just don't memoize.
               ;; This only occurs with eql specializers, at least with the standard c-a-m/-u-c methods.
               (gf-log-dispatch-miss "Cannot memoize call" generic-function vaslist-arguments)))
        (gf-log "Performing outcome %s%N" outcome)
        #+debug-fastgf
        (let ((results (multiple-value-list
                        (perform-outcome outcome arguments vaslist-arguments))))
          (gf-log "+-+-+-+-+-+-+-+-+ do-dispatch-miss done real time: %f seconds%N" (/ (float (- (get-internal-real-time) *dispatch-miss-start-time*)) internal-time-units-per-second))
          (gf-log "----}---- Completed call to effective-method-function for %s results -> %s%N" (clos::generic-function-name generic-function) results)
          (values-list results))
        #-debug-fastgf
        (perform-outcome outcome arguments vaslist-arguments)))))

(defun dispatch-miss (generic-function valist-args)
  (core:stack-monitor (lambda () (format t "In clos::dispatch-miss with generic function ~a~%" (clos::generic-function-name generic-function))))
  ;; update instances
  ;; Update any invalid instances
  (unwind-protect
       (progn
         (incf-debug-fastgf-indent)
         (let* ((arguments (core:list-from-va-list valist-args))
                (invalid-instance (maybe-update-instances arguments)))
           (if invalid-instance
               (apply generic-function valist-args)
               (progn
                 #+debug-fastgf
                 (progn
                   (gf-log "----{---- A dispatch-miss occurred -> %s  %N" (clos::generic-function-name generic-function))
                   (dolist (arg (core:list-from-va-list valist-args))
                     (gf-log "%s[%s/%d] " arg (class-of arg) (core:instance-stamp arg)))
                   (gf-log-noindent "%N"))
                 (do-dispatch-miss generic-function valist-args arguments)))))
    (decf-debug-fastgf-indent)))

;; (apply #'dispatch-miss-with-args gf vaslist) = (dispatch-miss gf vaslist)
;; TODO: Make APPLY good enough that we can lose one.
(defun dispatch-miss-with-args (generic-function core:&va-rest valist-args)
  (dispatch-miss generic-function valist-args))

;;; change-class requires removing call-history entries involving the class
;;; and invalidating the generic functions

(defun update-specializer-profile (generic-function specializers)
  (if (vectorp (generic-function-specializer-profile generic-function))
      (loop for vec = (generic-function-specializer-profile generic-function)
            for new-vec = (let ((new-vec (copy-seq vec)))
                            (loop for i from 0
                                  for spec in specializers
                                  for specialized = (not (eq spec clos:+the-t-class+))
                                  when specialized
                                    do (setf (elt new-vec i) t))
                            new-vec)
            for exchanged = (generic-function-specializer-profile-compare-exchange generic-function vec new-vec)
            until (eq exchanged new-vec))
      (warn "update-specializer-profile - Generic function ~a does not have a specializer-profile defined at this point" generic-function)))

(defun compute-and-set-specializer-profile (generic-function)
  ;; The profile is a simple vector with as many elements as the gf has
  ;; required arguments. Each element is true iff the corresponding
  ;; argument is specialized on (i.e., not T).
  (gf-log "compute-and-set-specializer-profile%N")
  ;; If the specializer profile doesn't yet exist, initialize it with a default
  ;; (all NILs)
  (unless (vectorp (generic-function-specializer-profile generic-function))
    (gf-log "compute-and-set-specializer-profile2%N")
    (initialize-generic-function-specializer-profile generic-function))
  (gf-log "compute-and-set-specializer-profile1%N")
  ;; Now do the actual computation.
  (let ((vec (make-array (length (generic-function-specializer-profile generic-function))
                         :initial-element nil))
        (methods (clos:generic-function-methods generic-function)))
    (gf-log "compute-and-set-specializer-profile1.5%N")
    (force-generic-function-specializer-profile generic-function vec)
    (when methods
      (loop for method in methods
         for specializers = (method-specializers method)
         do (update-specializer-profile generic-function specializers)))))

(defun calculate-fastgf-dispatch-function (generic-function &key output-path)
  (if (generic-function-call-history generic-function)
      (let ((call-history (generic-function-call-history generic-function))
            (specializer-profile (generic-function-specializer-profile generic-function)))
        (gf-log "calculate-fastgf-dispatch-function generic-function: %s (core:function-name generic-function) -> %s%N"
                generic-function
                (core:function-name generic-function))
        (cmp:codegen-dispatcher call-history
                                specializer-profile
                                generic-function
                                :generic-function-name (core:function-name generic-function)
                                :output-path output-path
                                #+debug-fastgf :log-gf
                                #+debug-fastgf (debug-fastgf-stream))) ;; the stream better be initialized
      ;; yes, this means we set a funcallable instance function to a symbol.
      ;; See comment on invalidate-discriminating-function (in method.lsp)
      'invalidated-dispatch-function))

(defun not-funcallable-dispatch-function (generic-function valist-args)
  (error "The funcallable-instance ~s is not funcallable" generic-function))

(defun force-dispatcher (generic-function)
  (let (log-output)
    #+debug-fastgf
    (progn
      (if (eq (class-of generic-function) (find-class 'standard-generic-function))
          (let ((generic-function-name (core:low-level-standard-generic-function-name generic-function)))
            (setf log-output (log-cmpgf-filename generic-function-name "func" "ll"))
            (gf-log "Writing dispatcher to %s%N" log-output))
          (setf log-output (log-cmpgf-filename (generic-function-name generic-function) "func" "ll")))
      (incf-debug-fastgf-didx))
    (set-funcallable-instance-function generic-function
                                       (calculate-fastgf-dispatch-function
                                        generic-function
                                        :output-path log-output))))

(defun invalidated-dispatch-function (generic-function valist-args)
  (declare (optimize (debug 3)))
  ;;; If there is a call history then compile a dispatch function
  ;;;   being extremely careful NOT to use any generic-function calls.
  ;;;   Then redo the call.
  ;;; If there is no call history then treat this like a dispatch-miss.
  #+debug-fastgf
  (if (eq (class-of generic-function) (find-class 'standard-generic-function))
      (gf-log "Entered invalidated-dispatch-function for %s - avoiding generic function calls until return!!!%N"
              (core:low-level-standard-generic-function-name generic-function))
      (gf-log "Entered invalidated-dispatch-function - avoiding generic function calls until return!!!%N"))
  (gf-log "Specializer profile is %s%N" (generic-function-specializer-profile generic-function))
  (if (generic-function-call-history generic-function)
      (progn
        (force-dispatcher generic-function)
        (apply generic-function valist-args))
      (dispatch-miss generic-function valist-args)))

;;; I don't believe the following few functions are called from anywhere, but they may be useful for debugging.

(defun method-spec-matches-entry-spec (method-spec entry-spec)
  (or
   (and (consp method-spec)
        (consp entry-spec)
        (eq (car method-spec) 'eql)
        (eql (second method-spec) (car entry-spec)))
   (and (classp method-spec) (classp entry-spec)
        (member method-spec (class-precedence-list entry-spec)))))

#+(or)
(defun call-history-entry-involves-method-with-specializers (entry method-specializers)
  (let ((key (car entry)))
    (loop for method-spec in method-specializers
       for entry-spec across key
       always (method-spec-matches-entry-spec method-spec entry-spec))))

#+(or)
(defun call-history-after-method-with-specializers-change (gf method-specializers)
  (loop for entry in (generic-function-call-history gf)
     unless (call-history-entry-involves-method-with-specializers entry method-specializers)
       collect entry))

#+(or)
(defun call-history-after-class-change (gf class)
;;;  (format t "call-history-after-class-change  start: gf->~a  call-history ->~a~%" gf (clos::generic-function-cal-history gf))
  (loop for entry in (generic-function-call-history gf)
     unless (loop for subclass in (subclasses* class)
               thereis (call-history-entry-key-contains-specializer (car entry) subclass))
     collect entry))

(defun subclasses* (class)
  (remove-duplicates
   (cons class
         (reduce #'append (mapcar #'subclasses*
                                  (class-direct-subclasses class))))))

(defun call-history-entry-key-contains-specializers (key specializers)
  (loop for specializer in specializers
        do (if (consp specializer)
               (loop with object = (car specializer)
                     for s in key
                     when (consp s)     ; eql specializer
                       do (when (eql (car s) object) (return-from call-history-entry-key-contains-specializers t)))
               (when (find specializer key :test #'eq)
                 (return-from call-history-entry-key-contains-specializers t)))))

(defun generic-function-call-history-separate-entries-with-specializers (gf call-history specializers)
  (gf-log "generic-function-call-history-remove-entries-with-specializers  gf: %s%N    specializers: %s%N" gf specializers)
  #+debug-long-call-history
  (when (> (length call-history) 16384)
    (error "DEBUG-LONG-CALL-HISTORY is triggered - The call history for ~a is longer (~a entries) than 16384" gf (length call-history)))
  (let ((removed nil) (keep nil))
    (loop for entry in call-history
          for key = (car entry)
          do (gf-log "         check if entry key: %s   contains specializer: %s%N" key specializers)
          if (call-history-entry-key-contains-specializers key specializers)
            do (progn
                 (gf-log "       It does - removing entry%N")
                 (push entry removed))
          else do (progn
                    (gf-log "       It does not - keeping entry%N")
                    (push entry keep)))
    #+debug-long-call-history
    (progn
      (unless (<= (length keep ) (length call-history))
        (error "The number of call history entries to keep (~a) MUST be less than the number of call-history entries ~a~%" (length keep) (length call-history)))
      (unless (<= (length removed ) (length call-history))
        (error "The number of call history entries removed (~a) MUST be less than the number of call-history entries ~a~%" (length removed) (length call-history)))
      (unless (= (+ (length removed) (length keep)) (length call-history))
        (error "The sum of removed and kept entries (+ ~a ~a) -> ~a does not equal the number of call-history entries ~a~%" (length removed) (length keep) (+ (length removed) (length keep)) (length call-history))))
    (values keep removed)))

(defun invalidate-generic-functions-with-class-selector (top-class)
  (gf-log "invalidate-generic-functions-with-class-specializer %s%N" top-class)
  (let* ((all-subclasses (subclasses* top-class))
         (_ (gf-log "  %d subclasses*%N" (length all-subclasses)))
         (_ (gf-log "        %s%N" all-subclasses))
         (generic-functions
           (loop for subclass in all-subclasses
                 for spec-generic-functions = (specializer-call-history-generic-functions subclass)
                 do (gf-log "   for subclass %s there are %d spec-generic-functions%N" subclass (length spec-generic-functions))
                 do (gf-log "         spec-generic-functions -> %s%N" spec-generic-functions)
                 append spec-generic-functions))
         (_ (gf-log "  %d generic-functions...%N" (length generic-functions)))
         (_ (gf-log "        %s%N" generic-functions))
         (unique-generic-functions (remove-duplicates generic-functions))
         (_ (gf-log "  unique-generic-functions...%N"))
         (_ (gf-log "        %s%N" unique-generic-functions))
         edited)
    (gf-log "   subclasses* -> %s%N" all-subclasses)
    ;;(when core:*debug-dispatch* (format t "    generic-functions: ~a~%" generic-functions))
    (loop for gf in unique-generic-functions
          do (let (edited-call-history)
               (gf-log "generic function: %s%N" (clos:generic-function-name gf))
               (gf-log "    (clos:get-funcallable-instance-function gf) -> %s%N" (clos:get-funcallable-instance-function gf))
               (gf-log "   NOT  editing call history and invalidating dispatch function due to metastability issues%N")
               (loop for call-history = (generic-function-call-history gf)
                     for new-call-history = (generic-function-call-history-separate-entries-with-specializers gf call-history all-subclasses)
                     for exchange = (generic-function-call-history-compare-exchange gf call-history new-call-history)
                     until (eq exchange new-call-history)
                     do (setf edited-call-history exchange))
               (gf-log "    edited call history%N")
               (gf-log "%s%N" edited-call-history)
               (gf-log "Generating a new discriminating function%N")
               (let (log-output)
                 #+debug-fastgf(progn
                                 (if (eq (class-of gf) (find-class 'standard-generic-function))
                                     (let ((generic-function-name (core:low-level-standard-generic-function-name gf)))
                                       (setf log-output (log-cmpgf-filename generic-function-name "func" "ll"))
                                       (gf-log "Writing dispatcher to %s%N" log-output))
                                     (setf log-output (log-cmpgf-filename (generic-function-name gf) "func" "ll")))
                                 (incf-debug-fastgf-didx))
                 (if edited-call-history
                     (let* ((specializer-profile (generic-function-specializer-profile gf))
                            (discriminating-function (cmp:codegen-dispatcher edited-call-history specializer-profile gf :output-path log-output)))
                       (set-funcallable-instance-function gf discriminating-function))
                     (invalidate-discriminating-function gf)))))))

(export '(invalidate-generic-functions-with-class-selector))
