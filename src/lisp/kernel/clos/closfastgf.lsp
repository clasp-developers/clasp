;;; ------------------------------------------------------------
;;;
;;; Generic function dispatch compiler
;;;   This implements the algorithm described by Robert Strandh for fast generic function dispatch
;;;
;;;   clos:generic-function-call-history is an alist of (past-call-signature . effective-method-closure)
;;;      The effective-method-closure is generated by combin.lsp:combine-method-functions3 and
;;;        the fptr always points to combin.lsp:combine-method-functions3.lambda
;;;        and is closed over the method and the rest-methods.
;;;      The past-call-signature is a simple-vector of classes for class-specializers
;;;        or (list eql-spec) for eql specializers.  The CAR of eql-spec is the EQL value and the
;;;        argument passed to the generic function.
;;;        eql-spec is the result of calling spec_type.unsafe_cons()->memberEql(spec_position_arg)
;;;          in the function fill_spec_vector.
;;;          https://github.com/drmeister/clasp/blob/dev/src/core/genericFunction.cc#L194
;;;
;;; clos:*enable-fastgf* and :fast-dispatch feature.
;;;    When the :fast-dispatch feature exists and clos:*enable-fastgf* == t
;;;    then fast dispatch will be used for new generic functions.

(in-package :clos)

;;; ------------------------------------------------------------
;;;
;;; Debugging code
;;;
;;; Add :LOG-CMPGF to log fastgf messages during the slow path.
;;;    
#+(or)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (pushnew :debug-fastgf *features*))


#+debug-fastgf
(eval-when (:execute :load-toplevel)
  (defstruct (debug-fastgf-struct (:type vector))
    stream
    didx
    indent
    miss-count)
  (defvar *dmspaces* "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ")
;;; Cleanup up the directory

  (defvar *dispatch-history-dir*
    (let ((dir (core:bformat nil "/tmp/dispatch-history-%d/" (core:getpid))))
      (ensure-directories-exist dir)
      (core:bformat *debug-io*  "!!!!  Created gf dispatch monitor directory: %s\n" dir)
      (core:bformat *debug-io*  "!!!!     Run clasp with --feature fastgf-dump-module to write dispatchers to this directory\n")
      (dolist (f (directory (core:bformat nil "%s/*.*" dir)))
        (delete-file f))
      dir))
  (defun lazy-initialize-debug-fastgf ()
    (unless core:*debug-fastgf*
      (let ((filename (core:bformat nil "%s/debug-miss-thread%s.log"
                                    *dispatch-history-dir*
                                    (core:pointer-as-string (mp:thread-id mp:*current-process*)))))
        (setf core:*debug-fastgf* (make-debug-fastgf-struct :stream (open filename :direction :output)
                                                            :didx 0
                                                            :indent 0
                                                            :miss-count (make-hash-table))))))
  (defun debug-fastgf-stream ()
    (lazy-initialize-debug-fastgf)
    (debug-fastgf-struct-stream core:*debug-fastgf*))
 
  (defun debug-fastgf-didx ()
    (lazy-initialize-debug-fastgf)
    (debug-fastgf-struct-didx core:*debug-fastgf*))
  (defun incf-debug-fastgf-didx ()
    (incf (debug-fastgf-struct-didx core:*debug-fastgf*)))
  
  (defun debug-fastgf-miss-count (gf)
    (gethash gf (debug-fastgf-struct-miss-count core:*debug-fastgf*) 0))
  (defun incf-debug-fastgf-miss-count (gf)
    (lazy-initialize-debug-fastgf)
    (incf (gethash gf (debug-fastgf-struct-miss-count core:*debug-fastgf*) 0)))
    
  (defun debug-fastgf-indent ()
    (debug-fastgf-struct-indent core:*debug-fastgf*))
  (defun incf-debug-fastgf-indent ()
    (lazy-initialize-debug-fastgf)
    (incf (debug-fastgf-struct-indent core:*debug-fastgf*) 2))
  (defun decf-debug-fastgf-indent ()
    (decf (debug-fastgf-struct-indent core:*debug-fastgf*) 2))
  
  (defmacro bformat-noindent (fmt &rest args)
    `(progn
       (lazy-initialize-debug-fastgf)
       (core:bformat (debug-fastgf-stream) ,fmt ,@args)))
  (defmacro bformat-indent (fmt &rest args)
    `(progn
       (lazy-initialize-debug-fastgf)
       (core:bformat (debug-fastgf-stream) (subseq *dmspaces* 0 (min (length *dmspaces*) (debug-fastgf-indent))))
       (core:bformat (debug-fastgf-stream) ,fmt ,@args)))
  (defun history-entry (entry)
    (mapcar (lambda (e)
              (if (consp e)
                  (list 'eql (car e))
                  e))
            (coerce entry 'list)))
  (defun graph-call-history (generic-function output)
    (cmp:generate-dot-file generic-function output))
  (defun log-cmpgf-filename (gfname suffix extension)
    (pathname (core:bformat nil "%s/dispatch-%s%05d-%s-thread%s.%s"
                            *dispatch-history-dir*
                            suffix
                            (debug-fastgf-didx)
                            (core:bformat nil "%s" gfname)
                            (pointer-as-string (mp:thread-id mp:*current-process*))
                            extension)))
  (defmacro gf-log-dispatch-graph (gf)
    `(graph-call-history ,gf (log-cmpgf-filename (clos::generic-function-name gf) "graph" "dot")))
  (defmacro gf-log-dispatch-miss-followup (msg &rest args)
    `(progn
       (bformat-indent "------- ")
       (bformat-noindent ,msg ,@args)))
  (defmacro gf-log-dispatch-miss-message (msg &rest args)
    `(bformat-indent ,msg ,@args))
  (defmacro gf-log-sorted-roots (roots)
    `(progn
       (bformat-indent ">>> sorted roots\n")
       (let ((x 0))
         (mapc (lambda (root)
                 (bformat-indent "  root[%d]: %s\n" (prog1 x (incf x)) root))))))
  (defmacro gf-log-dispatch-miss (msg gf va-args)
    `(progn
       (incf-debug-fastgf-didx)
       (incf-debug-fastgf-miss-count ,gf)
       (bformat-indent "------- DIDX:%d %s\n" (debug-fastgf-didx) ,msg)
       (bformat-indent "Dispatch miss #%d for %s\n" (debug-fastgf-miss-count ,gf) (clos::generic-function-name ,gf))
       (let* ((args-as-list (core:list-from-va-list ,va-args))
              (call-history (clos::generic-function-call-history ,gf))
              (specializer-profile (clos::generic-function-specializer-profile ,gf)))
         (bformat-indent "    args (num args -> %d):  " (length args-as-list))
         (dolist (arg args-as-list)
           (bformat-noindent "%s[%s/%d] " arg (class-of arg) (core:instance-stamp arg)))
         (bformat-indent "\n")
         (let ((index 0))
           (bformat-indent "    raw call-history (length -> %d):\n" (length call-history))
           (dolist (entry call-history)
             #+(or)(bformat-indent "    entry #%3d: %s\n" (prog1 index (incf index)) entry))
           (dolist (entry call-history)
             (bformat-indent "        entry#%3d: (" (prog1 index (incf index)))
             (dolist (c (history-entry (car entry)))
               (if (consp c)
                   (bformat-noindent "%s " c)
                   (bformat-noindent "[%s/%d] " (class-name c) (core:class-stamp-for-instances c))))
             (bformat-noindent ") -> %s\n" (core:object-address (cdr entry)))))
         (let ((optimized-call-history (cmp::optimized-call-history generic-function))
               (index 0))
           (bformat-indent "    optimized call-history (length -> %d):\n" (length optimized-call-history))
           (dolist (entry optimized-call-history)
             (bformat-indent "        entry#%3d: (" (prog1 index (incf index)))
             (let ((history-entry (history-entry (car entry))))
               ;;(bformat-indent "          ----> %s\n" history-entry)
               (dolist (c history-entry)
                 ;;(bformat-indent "    c -> %s   (type-of c) -> %s (consp c) -> %s\n" c (type-of c) (consp c))
                 (cond
                   ((consp c) (bformat-noindent "%s " c))
                   ((null c) (bformat-noindent "NIL "))
                   (t (bformat-noindent "[%s/%d] " (class-name c) (core:class-stamp-for-instances c))))))
             (bformat-noindent ")\n")))
         (finish-output (debug-fastgf-stream))
         #++(when (string= (subseq args 0 2) "''")
              (break "Check backtrace")))))
  (defmacro gf-log (fmt &rest fmt-args) `(bformat-indent ,fmt ,@fmt-args))
  (defmacro gf-log-noindent (fmt &rest fmt-args) `(bformat-noindent ,fmt ,@fmt-args))
  (defmacro gf-do (&body code) `(progn ,@code)))

#-debug-fastgf
(eval-when (:execute :load-toplevel)
  (defmacro gf-log-sorted-roots (roots) nil)
  (defmacro gf-log-dispatch-graph (gf) nil)
  (defmacro gf-log-dispatch-miss (msg gf va-args) nil)
  (defmacro gf-log-dispatch-miss-followup (msg &rest args) nil)
  (defmacro gf-log-dispatch-miss-message (msg &rest args) nil)
  (defmacro gf-log (fmt &rest fmt-args) nil)
  (defmacro gf-log-noindent (fmt &rest fmt-args) nil)
  (defmacro gf-do (&body code) nil)
  (defun incf-debug-fastgf-indent ())
  (defun decf-debug-fastgf-indent ())
  )
  


;;; --------------------------------------------------
;;;
;;; Switch to CLOS package here
;;;
;;; This section contains code that is called by CLOS to
;;;   update generic-function-call-history and to call
;;;   codegen-dispatcher to generate a new dispatch function when needed
;;;

(in-package :clos)

(defun specializers-as-list (arguments)
  (loop for arg in arguments
     for specializer = (if (consp arg) (car arg) 'T)
     collect specializer))

(defparameter *trap* nil)
(defparameter *dispatch-log* nil)

;;; Called from cc_dispatch_slot_reader_index via intrinsic_error
(defun fastgf-slot-unbound (opt-slot-reader instance)
  (slot-unbound (cmp::optimized-slot-reader-class opt-slot-reader)
                instance
                (cmp::optimized-slot-reader-slot-name opt-slot-reader)))

;;; Takes three arguments ((x cmp::optimized-slot-reader) instance vargs)
(defun dispatch-slot-reader-index-debug (opt-slot-reader instance vargs)
  ;; Do the slot read and check against the slot index
  (let ((opt-method (cmp::optimized-slot-reader-method opt-slot-reader))
        (opt-class (cmp::optimized-slot-reader-class opt-slot-reader))
        (slot-name (cmp::optimized-slot-reader-slot-name opt-slot-reader))
        (opt-index (cmp::optimized-slot-reader-index opt-slot-reader)))
    (let* ((slot (effective-slot-from-accessor-method opt-method opt-class :instance instance))
           (lookup-index (slot-definition-location slot)))
      (unless (= opt-index lookup-index)
        (error "The dispatch-slot-reader-index-debug function caught a difference between the slot opt-index ~a and the looked up slot index ~a for opt-method ~a/ opt-class ~a/ slot-name ~a" opt-index lookup-index opt-method opt-class slot-name))
      (let ((direct-result (core:instance-ref instance opt-index))
            (efm-result (funcall (cmp::optimized-slot-reader-effective-method-function opt-slot-reader) vargs nil)))
        (unless (eql direct-result efm-result)
          ;; Do what std-class-optimized-accessors does...
          (let* ((efm-class (si:instance-class instance))
                 (efm-table (class-location-table efm-class))
                 (efm-index (gethash slot-name efm-table))
                 (efm-value (if (si::fixnump efm-index)
                                (si:instance-ref instance (truly-the fixnum efm-index))
                                (car (truly-the cons efm-index)))))
            (format *debug-io* "DATA FOR READER ERROR!!!!!!!!!!!!!!!!!!!!!~%")
            (format *debug-io* "slot-name -----> ~s~%" slot-name)
            (format *debug-io* "opt-index -----> ~s~%" opt-index)
            (format *debug-io* "opt-method ----> ~s~%" opt-method)
            (format *debug-io* "opt-class -----> ~s~%" opt-class)
            (format *debug-io* "(core:instance-stamp instance) --------------------------------------------> ~s~%" (core:instance-stamp instance))
            (format *debug-io* "(core:lookup-class-with-stamp (core:instance-stamp instance)) -------------> ~s~%" (core:lookup-class-with-stamp (core:instance-stamp instance)))
            (format *debug-io* "(core:class-stamp-for-instances opt-class) --------------------------------> ~s~%" (core:class-stamp-for-instances opt-class))
            (format *debug-io* "(core:lookup-class-with-stamp (core:class-stamp-for-instances opt-class)) -> ~s~%" (core:lookup-class-with-stamp (core:class-stamp-for-instances opt-class)))
            (format *debug-io* "efm-class -----> ~s~%" efm-class)
            (format *debug-io* "efm-index -----> ~s~%" efm-index)
            (format *debug-io* "efm-value -----> ~s~%" efm-value)
            (format *debug-io* "(core::object-address instance) -> ~s~%" (core::object-address instance))
            (error "The dispatch-slot-reader-index-debug function caught a difference between reading the slot and calling the effective-method-function")))
        efm-result))))

;;; Takes four arguments ((x cmp::optimized-slot-writer) value instance vargs)
(defun dispatch-slot-writer-index-debug (opt-slot-writer value instance vargs)
  ;; Check against the slot index and Do the slot write and check against the slot index
  (let ((opt-method (cmp::optimized-slot-writer-method opt-slot-writer))
        (class (cmp::optimized-slot-writer-class opt-slot-writer))
        (slot-name (cmp::optimized-slot-writer-slot-name opt-slot-writer))
        (opt-index (cmp::optimized-slot-writer-index opt-slot-writer)))
    (let* ((slot (effective-slot-from-accessor-method opt-method class :instance instance))
           (lookup-index (slot-definition-location slot)))
      (unless (= opt-index lookup-index)
        (error "The dispatch-slot-writer-index-debug function caught a difference between the optimized slot index ~a and the looked up slot index ~a for opt-method ~a/ class ~a/ slot-name ~a" opt-index lookup-index opt-method class slot-name))
      (let ((efm-result (funcall (cmp::optimized-slot-writer-effective-method-function opt-slot-writer) vargs nil))
            (after-write-read (core:instance-ref instance opt-index)))
        (unless (eql efm-result after-write-read)
          (let ((*print-circle* nil))
            (error "The dispatch-slot-writer-index-debug function caught a difference between what should be in the slot opt-index ~a~% (read value -> ~s)~% after writing ~s into it using the effective-method-function.~% This is for opt-method ~s/class ~s/slot-name ~s~% and (core:class-stamp-for-instances class) -> ~s    (core:instance-stamp instance) -> ~s~%  (core:object-address instance) -> ~s~%" 
                   opt-index after-write-read efm-result opt-method class slot-name (core:class-stamp-for-instances class) (core:instance-stamp instance) (core:object-address instance))))
        efm-result))))

(defun maybe-update-instances (arguments)
  (let ((invalid-instance nil))
    (dolist (x arguments)
      (when (core:cxx-instance-p x)
        (let* ((i x)
               (s (si::instance-sig i)))
          (declare (:read-only i s))
          (clos::with-early-accessors (clos::+standard-class-slots+)
            (when (si::sl-boundp s)
              (unless (= (core:instance-stamp i) (core:class-stamp-for-instances (core:instance-class i)))
                (gf-log "   instance-stamp matches that of class -> %s\n"  (= (core:instance-stamp i) (core:class-stamp-for-instances (core:instance-class i))))
                (gf-log "(core:instance-stamp i) -> %s\n" (core:instance-stamp i))
                (gf-log "(core:class-stamp-for-instances (core:instance-class i)) -> %s\n" (core:class-stamp-for-instances (core:instance-class i)))
                (setf invalid-instance t)
                (clos::update-instance i)
                (core:instance-stamp-set i (core:class-stamp-for-instances (si:instance-class i)))))))))
    invalid-instance))

;; A call history selector a list of classes and eql-specializers
;; So to compute the applicable methods we need to consider the following cases for each
;; possible entry selector ...
;; 1) The selector is a list of just classes
;;      In that case behavior like that of compute-applicable-methods-using-classes can be used
;; 2) The selector is a mix of classes and eql-specializers
;;      In this case something like compute-applicable-methods needs to be used - but
;;         compute-applicable-methods takes a list of ARGUMENTS
;;        So I think we 
(defun applicable-method-p (method specializers)
  (loop for spec in (method-specializers method)
     for argspec in specializers
     always (if (eql-specializer-flag spec)
                (and (consp argspec) (eql (car argspec) (eql-specializer-object spec)))
                (and (not (consp argspec)) (subclassp argspec spec)))))

(defun applicable-method-list-using-specializers (gf specializers)
  (declare (optimize (speed 3))
	   (si::c-local))
  (with-early-accessors (+standard-method-slots+
			 +standard-generic-function-slots+
			 +eql-specializer-slots+
			 +standard-class-slots+)
    (loop for method in (generic-function-methods gf)
       when (applicable-method-p method specializers)
       collect method)))

(defun compute-applicable-methods-using-specializers (generic-function specializers)
  (check-type specializers list)
  (sort-applicable-methods generic-function
                           (applicable-method-list-using-specializers generic-function specializers)
                           (mapcar (lambda (s) (if (consp s)
                                                   (class-of (car s))
                                                   s))
                                   specializers)))

(defmacro with-generic-function-write-lock ((generic-function &optional (where "")) &body body)
  `(unwind-protect
        (progn
          (gf-log "with-generic-function-write-lock lock %s | %s\n" ,generic-function ,where)
          (mp:write-lock (generic-function-lock ,generic-function))
          ,@body)
     (progn
       (gf-log "with-generic-function-write-lock unlock %s | %s\n" ,generic-function ,where)
       (mp:write-unlock (generic-function-lock ,generic-function)))))

(defmacro with-generic-function-shared-lock ((generic-function &optional (where "")) &body body)
  `(unwind-protect
        (progn
          (gf-log "with-generic-function-shared-lock lock %s | %s\n" ,generic-function ,where)
          (mp:shared-lock (generic-function-lock ,generic-function))
          ,@body)
     (progn
       (gf-log "with-generic-function-shared-lock unlock %s | %s\n" ,generic-function ,where)
       (mp:shared-unlock (generic-function-lock ,generic-function)))))

(defun effective-slot-from-accessor-method (method class &key log instance)
  (let* ((direct-slot (accessor-method-slot-definition method))
         (direct-slot-name (slot-definition-name direct-slot))
         (effective-slot-defs (class-slots class))
         (slot (loop for effective-slot in effective-slot-defs
                     when (eq direct-slot-name (slot-definition-name effective-slot)) return effective-slot)))
    (when (null slot)
      (when log (gf-log "Could not find slot - starting from method %s got specializer class %s and slot-defs %s instance %s\n"
                        method class effective-slot-defs instance))
      (error "Could not find slot - starting from method ~s got specializer class ~s and slot-defs ~s and slot-name ~s : maybe-instance -> ~s"
             method class effective-slot-defs direct-slot-name instance))
    (when log (gf-log "++++ Slot value -> %s\n" slot))
    slot))

(defun compute-effective-method-function-maybe-optimize (generic-function method-combination methods actual-specializers &key log
                                                                                                                           actual-arguments)
  ;; Calculate the effective-method-function as well as an optimized one
  ;; so that we can apply the e-m-f to the arguments if we need to debug the optimized version.
  (let* ((efm (compute-effective-method-function generic-function
                                                 method-combination
                                                 methods))
         (optimized
           (flet ()
             (cond
               ((and (= (length methods) 1)
                     (typep (first methods) 'standard-reader-method)
                     #| FIXME TEST FOR slot-value-using-class |#)
                (when log (gf-log "++++ compute-effective-method-function-maybe-optimize optimizing reader\n"))
                (let* ((method (first methods))
                       (specializers (method-specializers method))
                       (class (first actual-specializers))
                       (slot (effective-slot-from-accessor-method method class :log log :instance (first actual-arguments))))
                  (when log (gf-log "++++ compute-effective-method-function-maybe-optimize optimizing reader data: %d\n" (slot-definition-location slot)))
                  (cmp::make-optimized-slot-reader :index (slot-definition-location slot)
                                                   :effective-method-function efm
                                                   :slot-name (slot-definition-name slot)
                                                   :method method
                                                   :class class)))
               ((and (= (length methods) 1)
                     (typep (first methods) 'standard-writer-method)
                     #| FIXME TEST FOR (setf slot-value-using-class) |#)
                (when log (gf-log "++++ compute-effective-method-function-maybe-optimize optimizing writer\n"))
                (let* ((method (first methods))
                       (specializers (method-specializers method))
                       (class (second actual-specializers))
                       (slot (effective-slot-from-accessor-method method class :log log :instance (first actual-arguments))))
                  (when log (gf-log "++++ compute-effective-method-function-maybe-optimize optimizing writer data: %d\n" (slot-definition-location slot)))
                  (cmp::make-optimized-slot-writer :index (slot-definition-location slot)
                                                   :effective-method-function efm
                                                   :slot-name (slot-definition-name slot)
                                                   :method method
                                                   :class class)))
               (t efm)))))
    #+debug-fastgf
    (when log
      (gf-log "vvv************************vvv\n")
      (gf-log "compute-effective-method-function for %s\n" (generic-function-name generic-function))
      (gf-log "There are %d methods...\n" (length methods))
      (dolist (m methods)
        (gf-log "Method: %s %s %s\n" (clos::method-specializers m) (clos::method-qualifiers m) m))
      (gf-log "Effective method function -> %s\n" optimized)
      (gf-log "Effective method function address -> %s\n" (core:object-address optimized))
      (gf-log "^^^************************^^^\n"))
    optimized))

(defun update-call-history-for-add-method (generic-function orig-call-history method)
  "When a method is added then we update the effective-method-functions for
   those call-history entries with specializers that the method would apply to."
  (let ((call-history (copy-list orig-call-history)))
    (loop for entry in call-history
       for specializers = (coerce (car entry) 'list)
       when (applicable-method-p method specializers)
       do (let* ((methods (compute-applicable-methods-using-specializers
                           generic-function
                           specializers))
                 (effective-method-function (compute-effective-method-function-maybe-optimize
                                             generic-function
                                             (generic-function-method-combination generic-function)
                                             methods
                                             specializers)))    ;;; I have actual specializers from the call history in specializers
            (rplacd entry effective-method-function)))
    call-history))

(defun update-generic-function-call-history-for-add-method (generic-function method)
  "When a method is added then we update the effective-method-functions for
   those call-history entries with specializers that the method would apply to.
FIXME!!!! This code will have problems with multithreading if a generic function is in flight. "
  (loop for call-history = (generic-function-call-history generic-function)
     for new-call-history = (update-call-history-for-add-method generic-function call-history method)
     for exchange = (generic-function-call-history-compare-exchange generic-function call-history new-call-history)
     until (eq exchange new-call-history)))

(defun update-call-history-for-remove-method (generic-function call-history method)
  (let (new-call-history)
    (loop for entry in call-history
       for specializers = (coerce (car entry) 'list)
       if (applicable-method-p method specializers)
       do (let* ((methods (compute-applicable-methods-using-specializers
                           generic-function
                           specializers))
                 (effective-method-function (if methods
                                                (compute-effective-method-function-maybe-optimize
                                                 generic-function
                                                 (generic-function-method-combination generic-function)
                                                 methods
                                                 specializers) ;; I have the actual specializers in specializers
                                                nil)))
            (when effective-method-function
              (push (cons (car entry) effective-method-function) new-call-history)))
       else
       do (push (cons (car entry) (cdr entry)) new-call-history))
    new-call-history))

(defun update-generic-function-call-history-for-remove-method (generic-function method)
  "When a method is removed then we update the effective-method-functions for
   those call-history entries with specializers that the method would apply to
    AND if that means there are no methods left that apply to the specializers
     then remove the entry from the list.
FIXME!!!! This code will have problems with multithreading if a generic function is in flight. "
  (loop for call-history = (generic-function-call-history generic-function)
     for new-call-history = (update-call-history-for-remove-method generic-function call-history method)
     for exchange = (generic-function-call-history-compare-exchange generic-function call-history new-call-history)
     until (eq exchange new-call-history)))

(defun calculate-discriminator-function (generic-function)
  "This is called from set-generic-function-dispatch - which is called whenever a method is added or removed "
  (let ((output-path (log-cmpgf-filename (clos::generic-function-name generic-function) "func" "ll")))
    (core::bformat *debug-io* "calculate-discriminator-function dumping dispatcher %s\n" output-path)
    (calculate-fastgf-dispatch-function generic-function
                                        #+debug-fastgf :output-path
                                        #+debug-fastgf output-path)))

(defun erase-generic-function-call-history (generic-function)
  (loop for call-history = (generic-function-call-history generic-function)
     for new-call-history = nil
     for exchange = (generic-function-call-history-compare-exchange generic-function call-history new-call-history)
     until (eq exchange new-call-history)))

(defun memoize-call (generic-function vaslist-arguments effective-method-function)
  "Memoizes the call and installs a new discriminator function - returns nothing"
  (gf-log-dispatch-miss "Adding to history" generic-function vaslist-arguments)
  (gf-log "about to call clos:memoization-key vaslist-arguments-> %s\n" vaslist-arguments)
  (loop for call-history = (clos::generic-function-call-history generic-function)
     for memoized-key = (clos:memoization-key generic-function vaslist-arguments)
     for found-key = (clos:call-history-find-key call-history memoized-key)
     for new-call-history = (if found-key
                                (progn
                                  (gf-log "The key was already in the history - maybe put there by another thread?\n")
                                  call-history)
                                (progn
                                  (gf-log "Pushing entry into call history\n")
                                  (cons (cons memoized-key effective-method-function) call-history)))
     for exchanged = (clos:generic-function-call-history-compare-exchange generic-function call-history new-call-history)
     when exchanged do (gf-log "Successfully exchanged call history\n")
     until (eq exchanged new-call-history))
  (set-funcallable-instance-function generic-function 'invalidated-dispatch-function)
  (return-from memoize-call))


(defun funcall-effective-method-function (efm arguments)
  (cond
    ((cmp::optimized-slot-reader-p efm)
     (funcall (cmp::optimized-slot-reader-effective-method-function efm) arguments nil))
    ((cmp::optimized-slot-writer-p efm)
     (funcall (cmp::optimized-slot-writer-effective-method-function efm) arguments nil))
    (t (funcall efm arguments nil))))

(defun do-dispatch-miss (generic-function vaslist-arguments arguments)
  "This effectively does what compute-discriminator-function does and maybe memoizes the result 
and calls the effective-method-function that is calculated.
It takes the arguments in two forms, as a vaslist and as a list of arguments."
  (let ((can-memoize t))
        ;; What if another thread adds/removes method during c-a-m-u-c???????
    (multiple-value-bind (method-list ok)
        (clos::compute-applicable-methods-using-classes generic-function (mapcar #'class-of arguments))
      (declare (core:lambda-name do-dispatch-miss.multiple-value-bind.lambda))
      ;; If ok is NIL then what do we use as the key
      (gf-log "Called compute-applicable-methods-using-classes - returned method-list: %s  ok: %s\n" method-list ok)
      (unless ok
        ;; What if another thread adds/removes method during c-a-m???????
        (setf method-list (clos::compute-applicable-methods generic-function arguments))
        (gf-log "compute-applicable-methods-using-classes returned NIL for second argument\n")
        ;; MOP says we can only memoize results if c-a-m-u-c returns T as its second return value.
        ;;  But for standard-generic-functions we can memoize the effective-method-function
        ;;  even if c-a-m-u-c returns NIL as its second return value
        ;;  because it is illegal to implement new methods on c-a-m specialized
        ;;  on standard-generic-function.
        (setf can-memoize (eq (class-of generic-function) (find-class 'standard-generic-function))))
      (if method-list
          (let ((effective-method-function (compute-effective-method-function-maybe-optimize
                                            generic-function
                                            (clos::generic-function-method-combination generic-function)
                                            method-list
                                            (mapcar #'core:instance-class arguments)
                                            :log t
                                            :actual-arguments arguments)))
            (when can-memoize (memoize-call generic-function vaslist-arguments effective-method-function))
            (gf-log "Calling effective-method-function %s\n" effective-method-function)
            #+debug-fastgf
            (let ((results (multiple-value-list (funcall-effective-method-function effective-method-function vaslist-arguments))))
              (gf-log "----}---- Completed call to effective-method-function for %s results -> %s\n" (clos::generic-function-name generic-function) results)
              (values-list results))
            #-debug-fastgf
            (funcall-effective-method-function effective-method-function vaslist-arguments))
          (progn
            (gf-log-dispatch-miss "no-applicable-method" generic-function vaslist-arguments)
            (apply #'no-applicable-method generic-function arguments))))))

(defun dispatch-miss (generic-function valist-args)
  (core:stack-monitor (lambda () (format t "In clos::dispatch-miss with generic function ~a~%" (clos::generic-function-name generic-function))))
  ;; update instances
  ;; Update any invalid instances
  (unwind-protect
       (progn
         (incf-debug-fastgf-indent)
         (let* ((arguments (core:list-from-va-list valist-args))
                (invalid-instance (maybe-update-instances arguments)))
           (if invalid-instance
               (apply generic-function valist-args)
               (progn
                 (gf-log "----{---- A dispatch-miss occurred -> %s  \n" (clos::generic-function-name generic-function))
                 (dolist (arg (core:list-from-va-list valist-args))
                   (gf-log-noindent "%s[%s/%d] " arg (class-of arg) (core:instance-stamp arg)))
                 (gf-log-noindent "\n")
                 (do-dispatch-miss generic-function valist-args arguments)))))
    (decf-debug-fastgf-indent)))

;;; change-class requires removing call-history entries involving the class
;;; and invalidating the generic functions

(defun update-specializer-profile (generic-function specializers)
  (if (vectorp (generic-function-specializer-profile generic-function))
      (loop for vec = (generic-function-specializer-profile generic-function)
         for new-vec = (let ((new-vec (copy-seq vec)))
                         (loop for i from 0
                            for spec in specializers
                            for specialized = (not (eq spec clos:+the-t-class+))
                            when specialized
                            do (setf (elt new-vec i) t))
                         new-vec)
         for exchanged = (generic-function-specializer-profile-compare-exchange generic-function vec new-vec)
         until (eq exchanged new-vec))
      (warn "update-specializer-profile - Generic function ~a does not have a specializer-profile defined at this point" generic-function)))


(defun compute-and-set-specializer-profile (generic-function)
  ;; The generic-function MUST have a specializer-profile defined already
  ;;   - it must be a simple-vector with size number-of-requred-arguments
  ;;     Each element is T if the corresponding argument is specialized on
  ;;        and NIL if it is not (all specializers are T).
  (gf-log "compute-and-set-specializer-profile\n")
  (unless (vectorp (generic-function-specializer-profile generic-function))
    (gf-log "compute-and-set-specializer-profile2\n")
    (initialize-generic-function-specializer-profile generic-function :errorp t))
  (gf-log "compute-and-set-specializer-profile1\n")
  (let ((vec (make-array (length (generic-function-specializer-profile generic-function))
                         :initial-element nil))
        (methods (clos:generic-function-methods generic-function)))
    (gf-log "compute-and-set-specializer-profile1.5\n")
    (initialize-generic-function-specializer-profile generic-function :initial-vec vec)
    (when methods
      (loop for method in methods
         for specializers = (method-specializers method)
         do (update-specializer-profile generic-function specializers)))))

(defun calculate-fastgf-dispatch-function (generic-function &key output-path)
  (if (generic-function-call-history generic-function)
      (cmp:codegen-dispatcher generic-function
                              :generic-function-name (core:function-name generic-function)
                              :output-path output-path
                              #+debug-fastgf :log-gf
                              #+debug-fastgf (debug-fastgf-stream)) ;; the stream better be initialized
      'invalidated-dispatch-function))

(defun invalidated-dispatch-function (generic-function valist-args)
  ;;; If there is a call history then compile a dispatch function
  ;;;   being extremely careful NOT to use any generic-function calls.
  ;;;   Then redo the call.
  ;;; If there is no call history then treat this like a dispatch-miss.
  #+debug-fastgf
  (if (eq (class-of generic-function) (find-class 'standard-generic-function))
      (gf-log "Entered invalidated-dispatch-function for %s - avoiding generic function calls until return!!!\n"
              (core:low-level-standard-generic-function-name generic-function))
      (gf-log "Entered invalidated-dispatch-function - avoiding generic function calls until return!!!\n"))
  (gf-log "Specializer profile is %s\n" (generic-function-specializer-profile generic-function))
  (if (generic-function-call-history generic-function)
      (let (log-output)
        #+debug-fastgf(progn
                        (if (eq (class-of generic-function) (find-class 'standard-generic-function))
                            (let ((generic-function-name (core:low-level-standard-generic-function-name generic-function)))
                              (setf log-output (log-cmpgf-filename generic-function-name "func" "ll"))
                              (gf-log "Writing dispatcher to %s\n" log-output))
                            (setf log-output (log-cmpgf-filename (generic-function-name generic-function) "func" "ll")))
                        (incf-debug-fastgf-didx))
        (set-funcallable-instance-function generic-function
                                           (calculate-fastgf-dispatch-function
                                            generic-function
                                            :output-path log-output))
        (apply generic-function valist-args))
      (dispatch-miss generic-function valist-args)))

;;; I don't believe the following four functions are called from anywhere, but they may be useful for debugging.

(defun method-spec-matches-entry-spec (method-spec entry-spec)
  (or
   (and (consp method-spec)
        (consp entry-spec)
        (eq (car method-spec) 'eql)
        (eql (second method-spec) (car entry-spec)))
   (and (classp method-spec) (classp entry-spec)
        (member method-spec (clos:class-precedence-list entry-spec)))))

#+(or)
(defun call-history-entry-involves-method-with-specializers (entry method-specializers)
  (let ((key (car entry)))
    (loop for method-spec in method-specializers
       for entry-spec across key
       always (method-spec-matches-entry-spec method-spec entry-spec))))

#+(or)
(defun call-history-after-method-with-specializers-change (gf method-specializers)
  (loop for entry in (generic-function-call-history gf)
     unless (call-history-entry-involves-method-with-specializers entry method-specializers)
     collect entry))

#+(or)
(defun call-history-after-class-change (gf class)
;;;  (format t "call-history-after-class-change  start: gf->~a  call-history ->~a~%" gf (clos::generic-function-cal-history gf))
  (loop for entry in (generic-function-call-history gf)
     unless (loop for subclass in (clos::subclasses* class)
               thereis (clos:call-history-entry-key-contains-specializer (car entry) subclass))
     collect entry))

(defun subclasses* (class)
  (remove-duplicates
   (cons class
         (reduce #'append (mapcar #'subclasses*
                                  (class-direct-subclasses class))))))

(defun invalidate-generic-functions-with-class-selector (top-class)
  (gf-log "invalidate-generic-functions-with-class-selector %s\n" top-class)
  (let* ((all-subclasses (subclasses* top-class))
         (_ (gf-log "  %d subclasses*\n" (length all-subclasses)))
         (_ (gf-log "        %s\n" all-subclasses))
         (generic-functions
          (loop for subclass in all-subclasses
             for spec-generic-functions = (specializer-call-history-generic-functions subclass)
             do (gf-log "   for subclass %s there are %d spec-generic-functions\n" subclass (length spec-generic-functions))
             do (gf-log "         spec-generic-functions -> %s\n" spec-generic-functions)
             append spec-generic-functions))
         (_ (gf-log "  %d generic-functions...\n" (length generic-functions)))
         (_ (gf-log "        %s\n" generic-functions))
         (unique-generic-functions (remove-duplicates generic-functions))
         (_ (gf-log "  unique-generic-functions...\n"))
         (_ (gf-log "        %s\n" unique-generic-functions))
         edited)
    (gf-log "   subclasses* -> %s\n" all-subclasses)
    ;;(when core:*debug-dispatch* (format t "    generic-functions: ~a~%" generic-functions))
    (loop for gf in unique-generic-functions
       when (typep (clos:get-funcallable-instance-function gf) 'core:compiled-dispatch-function)
       do (progn
            (loop for call-history = (generic-function-call-history gf)
               for new-call-history = (generic-function-call-history-separate-entries-with-specializers gf call-history all-subclasses)
               for exchange = (generic-function-call-history-compare-exchange call-history new-call-history)
               until (eq exchange new-call-history))
            (set-funcallable-instance-function gf
                                               'invalidated-dispatch-function
                                               #+(or)(clos::calculate-fastgf-dispatch-function gf))))))

(export '(invalidate-generic-functions-with-class-selector))
