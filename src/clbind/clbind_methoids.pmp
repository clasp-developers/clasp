//
$var ConstTypeCount = 2
    $var ReturnTypeCount = 2
    $var RetSV = 0
    $var RetVoid = 1
    $var NumArgs = 8
    $var InnerCount = NumArgs+1
    $var Templates = (InnerCount*ReturnTypeCount*ConstTypeCount)-1
    $var template_ = -1
    $range isConst 0..1
    $range ret 0..1
    $range innerCount 0..(InnerCount-1)
    $for isConst [[
        $for ret [[
                $for innerCount [[
                        $var template_ = isConst*(InnerCount*ReturnTypeCount)+ret*(InnerCount)+innerCount
                        $var numVoids = innerCount
                        $var numArgs = NumArgs - numVoids
                        $range Args_ 1..numArgs
                        // TEMPLATE_TOP
                        // template_ = $template_
                        // isConst = $isConst
                        // ret = $ret ($if ret==RetVoid [[void]] $else [[RetSV]]) 
                        //
                        // innerCount = $innerCount
                        // numArgs = $numArgs ($for Args_ , [[ARG$Args_]])
                        // numVoids = $numVoids
                        // 
                        /* Specialization  */
                        template <typename Pols, typename OT $if ret==RetVoid [[]] $else [[, typename RT ]] $if numArgs [[,]] $for Args_ ,[[typename ARG$Args_]] >
                        class IndirectVariadicMethoid
                        < Pols,OT $if ret==RetVoid [[,void]] $else [[,RT ]](OT::*)( $for Args_ , [[ARG$Args_]]) $if isConst [[const]] >
                        : public core::Functoid {
                        public:
//        typedef std::function<$if ret==RetVoid [[void]] $else [[RT]] (OT& $if numArgs [[,]] $for Args_ , [[ARG$Args_]])> Type;
                        typedef $if ret==RetVoid [[void]] $else [[RT]] (OT::*Type)( $for Args_ , [[ARG$Args_]]) $if isConst [[const]];
                        Type mptr;
                        public:
                        enum { NumParams = $numArgs };
                        IndirectVariadicMethoid(const string& name, Type ptr) : core::Functoid(name), mptr(ptr) {};

                    DISABLE_NEW();
                        core::T_mv activate( core::ActivationFrame_sp closedOverFrame, int numArgs, ArgArray args )
                        {
                            int countPureOutValues = CountPureOutValues<Pols>::value;
                            if ( numArgs-1 != (NumParams-countPureOutValues) )
                            {
                                core::wrongNumberOfArguments(numArgs,(NumParams-countPureOutValues)+1);
                            }
                            // /* Old way */OT* objPtr = (*args).as<core::WrappedPointer_O>()->cast<OT>();
                            translate::from_object<OT*> objPtr(*args);
                            //mem::smart_ptr<OT> ot((*args).as<OT>());
                            ++args;
                            $for Args_ [[
                                    translate::from_object<ARG$Args_,typename DoesNotContain_<Pols,pureOutValue<$Args_> >::type > a$Args_(*args);
                                    IncWhen<typename DoesNotContain_<Pols,pureOutValue<$Args_> >::type >::go(args);
                                    ]]
                                $if ret==RetVoid [[]] $else [[ RT retval = ]] ((*objPtr._v).*(this->mptr))($for Args_ ,[[a$Args_._v]]);
                            $if numArgs>0 [[
                                    core::MultipleValues& returnValues = _lisp->multipleValues();
                                    returnValues.setMaxSize();
                                    ]]
                                $if ret==RetVoid [[
                                    $if numArgs==0 [[]] $else [[ int oidx = 0; ]]
                                    ]] $else [[
                                    int oidx = 1;
                                    ]]
                                $for Args_ [[
                                ReturnValueWhen(returnValues,oidx
                                                , typename is_outValue<Pols,$Args_>::type()
                                                , typename AdoptPointer<Pols,$Args_>::type()
                                                , a$Args_._v);

                                    ]]
                                $if ret==RetVoid [[
                                    $if numArgs==0 [[
                                            return Values0<core::T_O>();
                                            ]] $else [[
                                            return mem::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
                                            ]]
                                    ]] $else [[
                                    return mem::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),oidx);
                                    ]]
          
                                }

                        };
                        ]]
                ]]
        ]]
