#! /usr/bin/env sbcl --noinform
(defun read-dtrace-header (stream &optional eofp eof)
  (list (read-line stream eofp eof)
        (read-line stream eofp eof)
;;        (read-line stream eofp eof)
        (read-line stream eofp eof)
        (read-line stream eofp eof)))

(defun remove-offset (line)
  (let ((offset (search "+0x" line)))
    (if offset
        (subseq line 0 offset)
        line)))

(defun read-dtrace-backtrace (stream &optional eofp eof)
  (loop for line = (read-line stream nil :eof)
     when (eq line :eof)
     do (if eofp
            (error "End of file encountered")
            (return-from read-dtrace-backtrace eof))
     until (= (length line) 0)
     collect (remove-offset line)))

(defun write-block (stream backtrace)
  (loop for x in backtrace
     do (princ x stream)
     do (terpri stream))
  (terpri stream))

(defun cleanup-frame (line)
  (let (pos)
    (cond
      ((setf pos (search "cclasp-boehm-image.fasl`" line))
       (concatenate 'string (subseq line 0 pos) (subseq line (+ pos #.(length "cclasp-boehm-image.fasl`")) (length line))))
      ((setf pos (search "iclasp-boehm`" line))
       (concatenate 'string (subseq line 0 pos) (subseq line (+ pos #.(length "iclasp-boehm`")) (length line))))
      (t line))))

(defun prune-backtrace (backtrace)
  (declare (optimize speed))
  (list*
   (cleanup-frame (car backtrace))
   (loop for line in (cdr backtrace)
      unless (search "VariadicFunctor" line)
      unless (search "core__call_with_variable_bound" line)
      unless (search "core::apply_method" line)
      unless (search "core::funcall_va_list" line)
      unless (search "core::funcall_consume_valist" line)
      unless (search "core::cl__apply" line)
      unless (search "FuncallableInstance_O::entry_point" line)
      unless (search "standard_dispatch" line)
      unless (search "funcall_frame" line)
      unless (search "cc_call_multipleValueOneFormCall" line)
      unless (search "core::core__funwind_protect" line)
      unless (search "core::core__multiple_value_prog1_function" line)
      unless (search "LAMBDA^^COMMON-LISP_FN" line)
      unless (search "COMBINE-METHOD-FUNCTIONS3.LAMBDA" line)
      collect (cleanup-frame line))))

(defun prune-dtrace-log (input output &key (verbose t))
  (let ((fin (open input :direction :input :external-format :latin-1))
        (fout (open output :direction :output :if-exists :supersede :external-format :latin-1))
        (count 0))
    (let ((header (read-dtrace-header fin)))
      (write-block fout header)
      (loop for backtrace = (read-dtrace-backtrace fin nil :eof)
         until (eq backtrace :eof)
         for pruned = (prune-backtrace backtrace)
         when (> (length backtrace) 4000)
         do (progn
              (format t "------------ input file pos: ~a~%" (file-position fin))
              (format t "Backtrace with ~a frames~%" (length backtrace))
              (format t "~a~%" pruned #++(last backtrace 5)))
         do (write-block fout pruned)
         do (incf count)))
    (when verbose (format t "Pruned ~a stacks~%" count))
    (close fin)
    (close fout)))


(defun remove-address (line)
  (let ((pos-plus (search "+0x" line :from-end t)))
    (if pos-plus
        (subseq line 0 pos-plus)
        line)))
  
(defun pick-tip (backtrace)
  (let ((line (first backtrace)))
    (cond
      ((search "VariadicFunctor" line) (remove-address (second backtrace)))
      ((search "VariadicMethoid" line) (remove-address (second backtrace)))
      ((search "SingleDispatchMethodFunction" line) (remove-address (second backtrace)))
      (t (remove-address line)))))

(defun trace-tips (fin)
  (let ((header (read-dtrace-header fin)))
    (declare (ignore header))
      (let ((tips (loop for backtrace = (read-dtrace-backtrace fin nil :eof)
                        until (eq backtrace :eof)
                        when (> (length backtrace) 0)
                          collect (pick-tip backtrace))))
        tips)))

(defun count-tips (input output)
  (let ((fin (open input :direction :input :external-format :latin-1))
        (fout (open output :direction :output :if-exists :supersede :external-format :latin-1)))
    (let ((tips (trace-tips fin))
          (counts (make-hash-table :test #'equal)))
      (loop for tip in tips
            do (incf (gethash tip counts 0)))
      (let (counted-tips)
        (maphash (lambda (k v)
                   (push (cons v k) counted-tips))
                 counts)
        (let ((sorted (sort counted-tips #'< :key #'car))
              (total 0)
              (gc-counts 0)
              (hash-table-counts 0))
          (loop for (count . name ) in sorted
                do (format fout "~5d  - ~a~%" count name)
                do (incf total count)
                do (cond
                     ((search "GC_" name)
                      (incf gc-counts count))
                     ((search "HashTable_O" name)
                      (incf hash-table-counts count))))
          (format fout "There are ~a backtraces~%" (length tips))
          (format fout "GC_ related counts: ~a~%" gc-counts)
          (format fout "HashTable_O related counts: ~a~%" hash-table-counts))))
    (close fin)
    (close fout)))


(defun trace-calls (fin)
  (let ((header (read-dtrace-header fin))
        (num-backtraces 0))
    (declare (ignore header))
    (let ((calls (loop for backtrace = (read-dtrace-backtrace fin nil :eof)
                       until (eq backtrace :eof)
                       when (> (length backtrace) 0)
                         append (butlast backtrace 1)
                       and do (incf num-backtraces))))
      (values calls num-backtraces))))


(defun count-calls (input output)
  (let ((fin (open input :direction :input :external-format :latin-1))
        (fout (open output :direction :output :if-exists :supersede :external-format :latin-1)))
    (multiple-value-bind (calls num-backtraces)
        (trace-calls fin)
      (let ((counts (make-hash-table :test #'equal)))
        (loop for call in calls
              do (incf (gethash call counts 0)))
        (let (counted-calls)
          (maphash (lambda (k v)
                     (push (cons v k) counted-calls))
                   counts)
          (let ((sorted (sort counted-calls #'< :key #'car))
                (total 0)
                (gc-counts 0)
                (hash-table-counts 0))
            (loop for (count . name ) in sorted
                  do (format fout "~5d ~5,3f  - ~a~%" count (float (/ count num-backtraces)) name)
                  do (incf total count)
                  do (cond
                       ((search "GC_" name)
                        (incf gc-counts count))
                       ((search "HashTable_O" name)
                        (incf hash-table-counts count))))
            (format fout "GC_ related counts: ~a~%" gc-counts)
            (format fout "HashTable_O related counts: ~a~%" hash-table-counts)))))
    (close fin)
    (close fout)))


(defun count-highest (fin stop-at)
  (let ((header (read-dtrace-header fin)))
    (declare (ignore header))
    (let ((counts (make-hash-table :test #'equal))
          (num-backtraces 0))
      (loop for backtrace = (read-dtrace-backtrace fin nil :eof)
            until (eq backtrace :eof)
            when (> (length backtrace) 0)
              do (incf num-backtraces)
            do (let ((one-bt-counts (make-hash-table :test #'equal)))
                 (loop for line in backtrace
                       for name = (string-trim " " line)
                       until (and stop-at (search stop-at name))
                       finally (setf (gethash name one-bt-counts) 1)
                       do (setf (gethash name one-bt-counts) 1))
                 (maphash (lambda (name present)
                            (declare (ignore present))
                            (incf (gethash name counts 0)))
                          one-bt-counts)))
      (let ((results nil))
        (maphash (lambda (name count)
                   (push (cons count name) results))
                 counts)
        (let ((sorted (sort results #'< :key #'car)))
          (values sorted num-backtraces))))))

(defun print-count-highest (namein nameout &key stop-at)
  (let ((fin (open namein :direction :input))
        (fout (open nameout :direction :output :if-exists :supersede)))
    (multiple-value-bind (sorted num-backtraces)
        (count-highest fin stop-at)
      (dolist (result sorted)
        (format fout "~5d ~5,3f ~a~%" (car result) (float (/ (car result) num-backtraces)) (cdr result)))
      (close fin)
      (close fout))))
    

(let ((cmd (third sb-ext:*posix-argv*))
      (args (make-hash-table :test #'equal)))
  (loop for cur = (cdddr sb-ext:*posix-argv*) then (cddr cur)
        for key = (car cur)
        for val = (cadr cur)
        while cur
        do (setf (gethash key args) val))
  (format *debug-io* "cmd = ~a~%" cmd)
  (cond
    ((search "prune-trace" cmd)
     (let ((in-file (gethash "-i" args))
           (out-file (gethash "-o" args)))
       (format t "prune ~a -> ~a~%" in-file out-file)
       (prune-dtrace-log in-file out-file)))
    ((search "count-tips" cmd)
     (let ((in-file (gethash "-i" args))
           (out-file (gethash "-o" args)))
       (count-tips in-file out-file)))
    ((search "count-calls" cmd)
     (let ((in-file (gethash "-i" args))
           (out-file (gethash "-o" args)))
       (count-calls in-file out-file)))
    ((search "count-highest" cmd)
     (format *debug-io* "count-highest~%")
     (let ((in-file (gethash "-i" args))
           (out-file (gethash "-o" args))
           (stop-at (gethash "-s" args nil)))
       (print-count-highest in-file out-file :stop-at stop-at)))
    (t (error "Unknown command"))))
