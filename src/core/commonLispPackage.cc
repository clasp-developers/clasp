/*
    File: commonLispPackage.cc
*/

/*
Copyright (c) 2014, Christian E. Schafmeister

CLASP is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

See directory 'clasp/licenses' for full details.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
/* -^- */

#include <clasp/core/foundation.h>
#include <clasp/core/object.h>
#include <clasp/core/lisp.h>
#include <clasp/core/symbol.h>
#include <clasp/core/commonLispPackage.h>
#include <clasp/core/multipleValues.h>
#include <clasp/core/package.h>

namespace cl {

SYMBOL_EXPORT_SC_(ClPkg, AMPallow_other_keys);
SYMBOL_EXPORT_SC_(ClPkg, AMPaux);
SYMBOL_EXPORT_SC_(ClPkg, AMPbody);
SYMBOL_EXPORT_SC_(ClPkg, AMPenvironment);
SYMBOL_EXPORT_SC_(ClPkg, AMPkey);
SYMBOL_EXPORT_SC_(ClPkg, AMPoptional);
SYMBOL_EXPORT_SC_(ClPkg, AMPrest);
SYMBOL_EXPORT_SC_(ClPkg, AMPwhole);
SYMBOL_EXPORT_SC_(ClPkg, Bit);
SYMBOL_EXPORT_SC_(ClPkg, MultipleValuesLimit);
SYMBOL_EXPORT_SC_(ClPkg, STARbreakOnSignalsSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARdebug_ioSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARdebuggerHookSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARdefaultPathnameDefaultsSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARerror_outputSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARfeaturesSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARgensym_counterSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARloadPathnameSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARloadTruenameSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARload_printSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARload_verboseSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARmacroexpand_hookSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARmodulesSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARpackageSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_arraySTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_baseSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_caseSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_circleSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_escapeSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_gensymSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_lengthSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_levelSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_linesSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_miser_widthSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_pprint_dispatchSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_prettySTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_radixSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_readablySTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARprint_right_marginSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARquery_ioSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARrandom_stateSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARreadDefaultFloatFormatSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARread_baseSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARread_evalSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARreadtableSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARstandard_inputSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARstandard_outputSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARterminal_ioSTAR);
SYMBOL_EXPORT_SC_(ClPkg, STARtrace_outputSTAR);
SYMBOL_EXPORT_SC_(ClPkg, SignedByte);
SYMBOL_EXPORT_SC_(ClPkg, T);
SYMBOL_EXPORT_SC_(ClPkg, UnsignedByte);
SYMBOL_EXPORT_SC_(ClPkg, _DIVIDE_);
SYMBOL_EXPORT_SC_(ClPkg, acos);
SYMBOL_EXPORT_SC_(ClPkg, acosh);
SYMBOL_EXPORT_SC_(ClPkg, adjust_array);
SYMBOL_EXPORT_SC_(ClPkg, allocate_instance);
SYMBOL_EXPORT_SC_(ClPkg, and);
SYMBOL_EXPORT_SC_(ClPkg, append);
SYMBOL_EXPORT_SC_(ClPkg, aref);
SYMBOL_EXPORT_SC_(ClPkg, arithmeticError);
SYMBOL_EXPORT_SC_(ClPkg, array);
SYMBOL_EXPORT_SC_(ClPkg, arrayDimension);
SYMBOL_EXPORT_SC_(ClPkg, arrayDimensionLimit);
SYMBOL_EXPORT_SC_(ClPkg, arrayTotalSizeLimit);
SYMBOL_EXPORT_SC_(ClPkg, array_has_fill_pointer_p);
SYMBOL_EXPORT_SC_(ClPkg, arrayp);
SYMBOL_EXPORT_SC_(ClPkg, asin);
SYMBOL_EXPORT_SC_(ClPkg, asinh);
SYMBOL_EXPORT_SC_(ClPkg, atanh);
SYMBOL_EXPORT_SC_(ClPkg, atom);
SYMBOL_EXPORT_SC_(ClPkg, base_char);
SYMBOL_EXPORT_SC_(ClPkg, base_string);
SYMBOL_EXPORT_SC_(ClPkg, bit);
SYMBOL_EXPORT_SC_(ClPkg, bit_vector);
SYMBOL_EXPORT_SC_(ClPkg, bit_vector_p);
SYMBOL_EXPORT_SC_(ClPkg, boole);
SYMBOL_EXPORT_SC_(ClPkg, boolean);
SYMBOL_EXPORT_SC_(ClPkg, break);
SYMBOL_EXPORT_SC_(ClPkg, broadcast_stream_streams);
SYMBOL_EXPORT_SC_(ClPkg, cadr);
SYMBOL_EXPORT_SC_(ClPkg, callArgumentsLimit);
SYMBOL_EXPORT_SC_(ClPkg, callNextMethod);
SYMBOL_EXPORT_SC_(ClPkg, car);
SYMBOL_EXPORT_SC_(ClPkg, cdr);
SYMBOL_EXPORT_SC_(ClPkg, cellError);
SYMBOL_EXPORT_SC_(ClPkg, char);
SYMBOL_EXPORT_SC_(ClPkg, character);
SYMBOL_EXPORT_SC_(ClPkg, characterp);
SYMBOL_EXPORT_SC_(ClPkg, class);
SYMBOL_EXPORT_SC_(ClPkg, class_name);
SYMBOL_EXPORT_SC_(ClPkg, compilation_speed);
SYMBOL_EXPORT_SC_(ClPkg, compile);
SYMBOL_EXPORT_SC_(ClPkg, compileFile);
SYMBOL_EXPORT_SC_(ClPkg, compiled_function_p);
SYMBOL_EXPORT_SC_(ClPkg, compiler_macro);
SYMBOL_EXPORT_SC_(ClPkg, compiler_macro_function);
SYMBOL_EXPORT_SC_(ClPkg, complexp);
SYMBOL_EXPORT_SC_(ClPkg, compute_restarts);
SYMBOL_EXPORT_SC_(ClPkg, concatenated_stream_streams);
SYMBOL_EXPORT_SC_(ClPkg, cond);
SYMBOL_EXPORT_SC_(ClPkg, condition);
SYMBOL_EXPORT_SC_(ClPkg, cons);
SYMBOL_EXPORT_SC_(ClPkg, consp);
SYMBOL_EXPORT_SC_(ClPkg, controlError);
SYMBOL_EXPORT_SC_(ClPkg, copy_structure);
SYMBOL_EXPORT_SC_(ClPkg, count);
SYMBOL_EXPORT_SC_(ClPkg, debug);
SYMBOL_EXPORT_SC_(ClPkg, declare);
SYMBOL_EXPORT_SC_(ClPkg, defconstant);
SYMBOL_EXPORT_SC_(ClPkg, define_compiler_macro);
SYMBOL_EXPORT_SC_(ClPkg, define_method_combination);
SYMBOL_EXPORT_SC_(ClPkg, define_modify_macro);
SYMBOL_EXPORT_SC_(ClPkg, defmacro);
SYMBOL_EXPORT_SC_(ClPkg, defparameter);
SYMBOL_EXPORT_SC_(ClPkg, defsetf);
SYMBOL_EXPORT_SC_(ClPkg, deftype);
SYMBOL_EXPORT_SC_(ClPkg, defun);
SYMBOL_EXPORT_SC_(ClPkg, defvar);
SYMBOL_EXPORT_SC_(ClPkg, describe);
SYMBOL_EXPORT_SC_(ClPkg, destructuring_bind);
SYMBOL_EXPORT_SC_(ClPkg, directory);
SYMBOL_EXPORT_SC_(ClPkg, disassemble);
SYMBOL_EXPORT_SC_(ClPkg, divisionByZero);
SYMBOL_EXPORT_SC_(ClPkg, do);
SYMBOL_EXPORT_SC_(ClPkg, documentation);
SYMBOL_EXPORT_SC_(ClPkg, dolist);
SYMBOL_EXPORT_SC_(ClPkg, dotimes);
SYMBOL_EXPORT_SC_(ClPkg, double_float);
SYMBOL_EXPORT_SC_(ClPkg, dynamic_extent);
SYMBOL_EXPORT_SC_(ClPkg, echo_stream_input_stream);
SYMBOL_EXPORT_SC_(ClPkg, echo_stream_output_stream);
SYMBOL_EXPORT_SC_(ClPkg, elt);
SYMBOL_EXPORT_SC_(ClPkg, endOfFile);
SYMBOL_EXPORT_SC_(ClPkg, endp);
SYMBOL_EXPORT_SC_(ClPkg, eq);
SYMBOL_EXPORT_SC_(ClPkg, eql);
SYMBOL_EXPORT_SC_(ClPkg, equal);
SYMBOL_EXPORT_SC_(ClPkg, equalp);
SYMBOL_EXPORT_SC_(ClPkg, error);
SYMBOL_EXPORT_SC_(ClPkg, etypecase);
SYMBOL_EXPORT_SC_(ClPkg, eval);
SYMBOL_EXPORT_SC_(ClPkg, every);
SYMBOL_EXPORT_SC_(ClPkg, extended_char);
SYMBOL_EXPORT_SC_(ClPkg, fileError);
SYMBOL_EXPORT_SC_(ClPkg, fileStream);
SYMBOL_EXPORT_SC_(ClPkg, file_string_length);
SYMBOL_EXPORT_SC_(ClPkg, fillPointer);
SYMBOL_EXPORT_SC_(ClPkg, fill_pointer);
SYMBOL_EXPORT_SC_(ClPkg, find_restart);
SYMBOL_EXPORT_SC_(ClPkg, first);
SYMBOL_EXPORT_SC_(ClPkg, fixnum);
SYMBOL_EXPORT_SC_(ClPkg, float);
SYMBOL_EXPORT_SC_(ClPkg, floatingPointInexact);
SYMBOL_EXPORT_SC_(ClPkg, floatingPointInvalidOperation);
SYMBOL_EXPORT_SC_(ClPkg, floatingPointOverflow);
SYMBOL_EXPORT_SC_(ClPkg, floatingPointUnderflow);
SYMBOL_EXPORT_SC_(ClPkg, floatp);
SYMBOL_EXPORT_SC_(ClPkg, ftype);
SYMBOL_EXPORT_SC_(ClPkg, function);
SYMBOL_EXPORT_SC_(ClPkg, functionp);
SYMBOL_EXPORT_SC_(ClPkg, generic_function);
SYMBOL_EXPORT_SC_(ClPkg, get);
SYMBOL_EXPORT_SC_(ClPkg, getInternalRealTime);
SYMBOL_EXPORT_SC_(ClPkg, getInternalRunTime);
SYMBOL_EXPORT_SC_(ClPkg, getOutputStreamString);
SYMBOL_EXPORT_SC_(ClPkg, gethash);
SYMBOL_EXPORT_SC_(ClPkg, hash_table);
SYMBOL_EXPORT_SC_(ClPkg, hash_table_p);
SYMBOL_EXPORT_SC_(ClPkg, ignorable);
SYMBOL_EXPORT_SC_(ClPkg, inline);
SYMBOL_EXPORT_SC_(ClPkg, input_stream_p);
SYMBOL_EXPORT_SC_(ClPkg, integer);
SYMBOL_EXPORT_SC_(ClPkg, integerp);
SYMBOL_EXPORT_SC_(ClPkg, internalTimeUnitsPerSecond);
SYMBOL_EXPORT_SC_(ClPkg, intersection);
SYMBOL_EXPORT_SC_(ClPkg, invoke_restart);
SYMBOL_EXPORT_SC_(ClPkg, keyword);
SYMBOL_EXPORT_SC_(ClPkg, keywordp);
SYMBOL_EXPORT_SC_(ClPkg, lambda);
SYMBOL_EXPORT_SC_(ClPkg, lambdaParametersLimit);
SYMBOL_EXPORT_SC_(ClPkg, length);
SYMBOL_EXPORT_SC_(ClPkg, list);
SYMBOL_EXPORT_SC_(ClPkg, listp);
SYMBOL_EXPORT_SC_(ClPkg, load);
SYMBOL_EXPORT_SC_(ClPkg, logicalPathnameTranslations);
SYMBOL_EXPORT_SC_(ClPkg, logical_pathname);
SYMBOL_EXPORT_SC_(ClPkg, long_float);
SYMBOL_EXPORT_SC_(ClPkg, makeArray);
SYMBOL_EXPORT_SC_(ClPkg, makeCondition);
SYMBOL_EXPORT_SC_(ClPkg, makePathname);
SYMBOL_EXPORT_SC_(ClPkg, make_instance);
SYMBOL_EXPORT_SC_(ClPkg, make_string_input_stream);
SYMBOL_EXPORT_SC_(ClPkg, make_synonym_stream);
SYMBOL_EXPORT_SC_(ClPkg, make_two_way_stream);
SYMBOL_EXPORT_SC_(ClPkg, member);
SYMBOL_EXPORT_SC_(ClPkg, method);
SYMBOL_EXPORT_SC_(ClPkg, mismatch);
SYMBOL_EXPORT_SC_(ClPkg, multipleValueCall);
SYMBOL_EXPORT_SC_(ClPkg, nconc);
SYMBOL_EXPORT_SC_(ClPkg, nextMethodP);
SYMBOL_EXPORT_SC_(ClPkg, nil);
SYMBOL_EXPORT_SC_(ClPkg, notinline);
SYMBOL_EXPORT_SC_(ClPkg, nth);
SYMBOL_EXPORT_SC_(ClPkg, null);
SYMBOL_EXPORT_SC_(ClPkg, numberp);
SYMBOL_EXPORT_SC_(ClPkg, open_stream_p);
SYMBOL_EXPORT_SC_(ClPkg, optimize);
SYMBOL_EXPORT_SC_(ClPkg, or);
SYMBOL_EXPORT_SC_(ClPkg, output_stream_p);
SYMBOL_EXPORT_SC_(ClPkg, package);
SYMBOL_EXPORT_SC_(ClPkg, package_error);
SYMBOL_EXPORT_SC_(ClPkg, packagep);
SYMBOL_EXPORT_SC_(ClPkg, parseError);
SYMBOL_EXPORT_SC_(ClPkg, parseNamestring);
SYMBOL_EXPORT_SC_(ClPkg, parse_namestring);
SYMBOL_EXPORT_SC_(ClPkg, pathname);
SYMBOL_EXPORT_SC_(ClPkg, pathnamep);
SYMBOL_EXPORT_SC_(ClPkg, position);
SYMBOL_EXPORT_SC_(ClPkg, pprint_dispatch);
SYMBOL_EXPORT_SC_(ClPkg, printNotReadable);
SYMBOL_EXPORT_SC_(ClPkg, printNotReadableObject);
SYMBOL_EXPORT_SC_(ClPkg, printObject);
SYMBOL_EXPORT_SC_(ClPkg, progn);
SYMBOL_EXPORT_SC_(ClPkg, programError);
SYMBOL_EXPORT_SC_(ClPkg, provide);
SYMBOL_EXPORT_SC_(ClPkg, quote);
SYMBOL_EXPORT_SC_(ClPkg, random);
SYMBOL_EXPORT_SC_(ClPkg, rationalp);
SYMBOL_EXPORT_SC_(ClPkg, read_char);
SYMBOL_EXPORT_SC_(ClPkg, read_sequence);
SYMBOL_EXPORT_SC_(ClPkg, readerError);
SYMBOL_EXPORT_SC_(ClPkg, realp);
SYMBOL_EXPORT_SC_(ClPkg, remove);
SYMBOL_EXPORT_SC_(ClPkg, rename_file);
SYMBOL_EXPORT_SC_(ClPkg, rest);
SYMBOL_EXPORT_SC_(ClPkg, restart);
SYMBOL_EXPORT_SC_(ClPkg, restartName);
SYMBOL_EXPORT_SC_(ClPkg, restart_bind);
SYMBOL_EXPORT_SC_(ClPkg, safety);
SYMBOL_EXPORT_SC_(ClPkg, satisfies);
SYMBOL_EXPORT_SC_(ClPkg, schar);
SYMBOL_EXPORT_SC_(ClPkg, sequence);
SYMBOL_EXPORT_SC_(ClPkg, seriousCondition);
SYMBOL_EXPORT_SC_(ClPkg, set);
SYMBOL_EXPORT_SC_(ClPkg, short_float);
SYMBOL_EXPORT_SC_(ClPkg, simpleCondition);
SYMBOL_EXPORT_SC_(ClPkg, simpleError);
SYMBOL_EXPORT_SC_(ClPkg, simpleTypeError);
SYMBOL_EXPORT_SC_(ClPkg, simpleWarning);
SYMBOL_EXPORT_SC_(ClPkg, simple_array);
SYMBOL_EXPORT_SC_(ClPkg, simple_base_string);
SYMBOL_EXPORT_SC_(ClPkg, simple_bit_vector);
SYMBOL_EXPORT_SC_(ClPkg, simple_bit_vector_p);
SYMBOL_EXPORT_SC_(ClPkg, simple_string_p);
SYMBOL_EXPORT_SC_(ClPkg, simple_type_error);
SYMBOL_EXPORT_SC_(ClPkg, simple_vector);
SYMBOL_EXPORT_SC_(ClPkg, simple_vector_p);
SYMBOL_EXPORT_SC_(ClPkg, sin);
SYMBOL_EXPORT_SC_(ClPkg, single_float);
SYMBOL_EXPORT_SC_(ClPkg, slot_unbound);
SYMBOL_EXPORT_SC_(ClPkg, slot_value);
SYMBOL_EXPORT_SC_(ClPkg, some);
SYMBOL_EXPORT_SC_(ClPkg, space);
SYMBOL_EXPORT_SC_(ClPkg, special);
SYMBOL_EXPORT_SC_(ClPkg, speed);
SYMBOL_EXPORT_SC_(ClPkg, standard_char);
SYMBOL_EXPORT_SC_(ClPkg, standard_class);
SYMBOL_EXPORT_SC_(ClPkg, standard_object);
SYMBOL_EXPORT_SC_(ClPkg, step);
SYMBOL_EXPORT_SC_(ClPkg, storageCondition);
SYMBOL_EXPORT_SC_(ClPkg, stream);
SYMBOL_EXPORT_SC_(ClPkg, streamError);
SYMBOL_EXPORT_SC_(ClPkg, stream_element_type);
SYMBOL_EXPORT_SC_(ClPkg, stream_external_format);
SYMBOL_EXPORT_SC_(ClPkg, string);
SYMBOL_EXPORT_SC_(ClPkg, stringp);
SYMBOL_EXPORT_SC_(ClPkg, structure_object);
SYMBOL_EXPORT_SC_(ClPkg, styleWarning);
SYMBOL_EXPORT_SC_(ClPkg, subseq);
SYMBOL_EXPORT_SC_(ClPkg, substitute);
SYMBOL_EXPORT_SC_(ClPkg, subtypep);
SYMBOL_EXPORT_SC_(ClPkg, symbol);
SYMBOL_EXPORT_SC_(ClPkg, symbolp);
SYMBOL_EXPORT_SC_(ClPkg, synonym_stream_symbol);
SYMBOL_EXPORT_SC_(ClPkg, two_way_stream);
SYMBOL_EXPORT_SC_(ClPkg, two_way_stream_input_stream);
SYMBOL_EXPORT_SC_(ClPkg, two_way_stream_output_stream);
SYMBOL_EXPORT_SC_(ClPkg, type);
SYMBOL_EXPORT_SC_(ClPkg, type_error);
SYMBOL_EXPORT_SC_(ClPkg, typep);
SYMBOL_EXPORT_SC_(ClPkg, unboundSlot);
SYMBOL_EXPORT_SC_(ClPkg, unboundVariable);
SYMBOL_EXPORT_SC_(ClPkg, undefinedFunction);
SYMBOL_EXPORT_SC_(ClPkg, union);
SYMBOL_EXPORT_SC_(ClPkg, upgraded_array_element_type);
SYMBOL_EXPORT_SC_(ClPkg, values);
SYMBOL_EXPORT_SC_(ClPkg, variable);
SYMBOL_EXPORT_SC_(ClPkg, vector);
SYMBOL_EXPORT_SC_(ClPkg, vectorp);
SYMBOL_EXPORT_SC_(ClPkg, warn);
SYMBOL_EXPORT_SC_(ClPkg, warning);
SYMBOL_EXPORT_SC_(ClPkg, write);
SYMBOL_EXPORT_SC_(ClPkg, write_line);
SYMBOL_EXPORT_SC_(ClPkg, write_sequence);
SYMBOL_EXPORT_SC_(ClPkg, write_string);

#define ClPkg_SYMBOLS

//    SYMBOL_EXPORT_SC_(ClPkg,defaultPathnameDefaults);

}; // namespace cl
