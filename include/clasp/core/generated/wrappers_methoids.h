// This file was GENERATED by command:
//     pump.py wrappers_methoids.pmp
// DO NOT EDIT BY HAND!!!

//
// Methods
//
// Three kinds of return values    single-value, multiple-value and void                              //
// ret = 0  RetSV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,
    a15._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,RT (OT::*)( )  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)() ;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*ot.untag_object()).*mptr)();
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
((*ot.untag_object()).*mptr)(a1._v,a2._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
((*ot.untag_object()).*mptr)(a1._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn , typename OT  >
class VariadicMethoid
<DispatchOn,void (OT::*)( )  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)() ;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
((*ot.untag_object()).*mptr)();
return Values0<core::T_O>();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v,a13._v,a14._v,a15._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v,a13._v,a14._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v,a13._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1)  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( )  >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)() ;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)();
return retval.as_return_type();
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,
    a15._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
RT retval =  ((*ot.untag_object()).*mptr)(a1._v);
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)() const;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*ot.untag_object()).*mptr)();
return Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
((*ot.untag_object()).*mptr)(a1._v,a2._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
((*ot.untag_object()).*mptr)(a1._v);
return Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn , typename OT  >
class VariadicMethoid
<DispatchOn,void (OT::*)( ) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)() const;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
((*ot.untag_object()).*mptr)();
return Values0<core::T_O>();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v,a13._v,a14._v,a15._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v,a13._v,a14._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v,a13._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v,a12._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,
    a11._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v,a4._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v,a3._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v,a2._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
translate::from_object<ARG1> a1(frame->arg(1));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)(a1._v);
return retval.as_return_type();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ) const >
: public BuiltinClosure_O {
public:
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)() const;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gctools::smart_ptr<OT>>(frame->arg(0)));
gctools::multiple_values<RT> retval =  ((*ot.untag_object()).*mptr)();
return retval.as_return_type();
}
};

