// This file was GENERATED by command:
//     pump.py external_wrappers_indirect_methoids.pmp
// DO NOT EDIT BY HAND!!!

// TEMPLATE_TOP
// template_ = 0
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)>
// Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v,a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 1
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 2
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 3
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 4
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 5
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 6
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 7
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 8
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 9
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 10
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 11
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 12
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 13
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 14
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 15
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( )  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,)> Type;
typedef RT (OT::ExternalType::*Type)( ) ;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 16
// isConst = 0
// ret = 1 (void)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
// ARG15)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,
    a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 17
// isConst = 0
// ret = 1 (void)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 18
// isConst = 0
// ret = 1 (void)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 19
// isConst = 0
// ret = 1 (void)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 20
// isConst = 0
// ret = 1 (void)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 21
// isConst = 0
// ret = 1 (void)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 22
// isConst = 0
// ret = 1 (void)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 23
// isConst = 0
// ret = 1 (void)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 24
// isConst = 0
// ret = 1 (void)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 25
// isConst = 0
// ret = 1 (void)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 26
// isConst = 0
// ret = 1 (void)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 27
// isConst = 0
// ret = 1 (void)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 28
// isConst = 0
// ret = 1 (void)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 29
// isConst = 0
// ret = 1 (void)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 30
// isConst = 0
// ret = 1 (void)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1)  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1)> Type;
typedef void (OT::ExternalType::*Type)( ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 31
// isConst = 0
// ret = 1 (void)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( )  >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,)> Type;
typedef void (OT::ExternalType::*Type)( ) ;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 32
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)>
// Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v,a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 33
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 34
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 35
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 36
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 37
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 38
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 39
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 40
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 41
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 42
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 43
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 44
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 45
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 46
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 47
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<RT (OT& ,)> Type;
typedef RT (OT::ExternalType::*Type)( ) const;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
return LCC_RETURN(translate::to_object<RT>::convert(std::move(retval)).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 48
// isConst = 1
// ret = 1 (void)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
// ARG15)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
translate::from_object<ARG15> a15(frame->arg(15));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,
    a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 49
// isConst = 1
// ret = 1 (void)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
translate::from_object<ARG14> a14(frame->arg(14));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 50
// isConst = 1
// ret = 1 (void)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
translate::from_object<ARG13> a13(frame->arg(13));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 51
// isConst = 1
// ret = 1 (void)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
translate::from_object<ARG12> a12(frame->arg(12));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 52
// isConst = 1
// ret = 1 (void)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
translate::from_object<ARG11> a11(frame->arg(11));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 53
// isConst = 1
// ret = 1 (void)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
translate::from_object<ARG10> a10(frame->arg(10));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 54
// isConst = 1
// ret = 1 (void)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
translate::from_object<ARG9> a9(frame->arg(9));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 55
// isConst = 1
// ret = 1 (void)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
translate::from_object<ARG8> a8(frame->arg(8));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 56
// isConst = 1
// ret = 1 (void)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
translate::from_object<ARG7> a7(frame->arg(7));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 57
// isConst = 1
// ret = 1 (void)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
translate::from_object<ARG6> a6(frame->arg(6));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 58
// isConst = 1
// ret = 1 (void)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
translate::from_object<ARG5> a5(frame->arg(5));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 59
// isConst = 1
// ret = 1 (void)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
translate::from_object<ARG4> a4(frame->arg(4));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 60
// isConst = 1
// ret = 1 (void)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
translate::from_object<ARG3> a3(frame->arg(3));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 61
// isConst = 1
// ret = 1 (void)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
translate::from_object<ARG2> a2(frame->arg(2));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 62
// isConst = 1
// ret = 1 (void)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1)> Type;
typedef void (OT::ExternalType::*Type)( ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
translate::from_object<ARG1> a1(frame->arg(1));
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};
// TEMPLATE_TOP
// template_ = 63
// isConst = 1
// ret = 1 (void)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ) const >
: public BuiltinClosure_O {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure_O TemplatedBase;
public:
//        typedef std::function<void (OT& ,)> Type;
typedef void (OT::ExternalType::*Type)( ) const;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure_O(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
inline LCC_RETURN LISP_CALLING_CONVENTION()
{
INCREMENT_FUNCTION_CALL_COUNTER(this);
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
MAKE_STACK_FRAME(frame,this->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this->asSmartPtr(),this->_lambdaListHandler,scope,LCC_PASS_ARGS);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(frame->arg(0)));
((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),frame->arg(0));
return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}

};



