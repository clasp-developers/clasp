// This file was GENERATED by command:
//     pump.py external_wrappers_indirect_methoids.pmp
// DO NOT EDIT BY HAND!!!

// TEMPLATE_TOP
// template_ = 0
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)>
// Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) , frame::Value(frameImpl,15)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v,a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 1
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 2
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 3
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 4
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 5
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 6
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 7
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 8
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 9
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 10
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 11
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 12
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 13
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 14
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1 )
{
translate::from_object<ARG1> a1(arg1);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 15
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( )  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,)> Type;
typedef RT (OT::ExternalType::*Type)( ) ;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0)  );
}

LCC_RETURN invoke( core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 16
// isConst = 0
// ret = 1 (void)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
// ARG15)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) , frame::Value(frameImpl,15)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,
    a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 17
// isConst = 0
// ret = 1 (void)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 18
// isConst = 0
// ret = 1 (void)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 19
// isConst = 0
// ret = 1 (void)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 20
// isConst = 0
// ret = 1 (void)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 21
// isConst = 0
// ret = 1 (void)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 22
// isConst = 0
// ret = 1 (void)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 23
// isConst = 0
// ret = 1 (void)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 24
// isConst = 0
// ret = 1 (void)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 25
// isConst = 0
// ret = 1 (void)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 26
// isConst = 0
// ret = 1 (void)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 27
// isConst = 0
// ret = 1 (void)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 28
// isConst = 0
// ret = 1 (void)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 29
// isConst = 0
// ret = 1 (void)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 30
// isConst = 0
// ret = 1 (void)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1)  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1)> Type;
typedef void (OT::ExternalType::*Type)( ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1 )
{
translate::from_object<ARG1> a1(arg1);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 31
// isConst = 0
// ret = 1 (void)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( )  >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,)> Type;
typedef void (OT::ExternalType::*Type)( ) ;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0)  );
}

LCC_RETURN invoke( core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 32
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)>
// Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) , frame::Value(frameImpl,15)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v,a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 33
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 34
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 35
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 36
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 37
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 38
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 39
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 40
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 41
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 42
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 43
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 44
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2, ARG3)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 45
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1, ARG2) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1, ARG2)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 46
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ARG1) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,ARG1)> Type;
typedef RT (OT::ExternalType::*Type)( ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1 )
{
translate::from_object<ARG1> a1(arg1);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 47
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename RT,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::ExternalType::*)( ) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<RT (OT& ,)> Type;
typedef RT (OT::ExternalType::*Type)( ) const;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0)  );
}

LCC_RETURN invoke( core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
RT retval =  ((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
return gctools::multiple_values<T_O>(translate::to_object<RT>::convert(std::move(retval)),oidx);
}

};
// TEMPLATE_TOP
// template_ = 48
// isConst = 1
// ret = 1 (void)
//
// innerCount = 0
// numArgs = 16 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)
// numVoids = 0
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
// ARG15)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 16 ) core::wrongNumberOfArguments(lcc_nargs,16);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) , frame::Value(frameImpl,15)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,
    a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<15> >::type,
typename Contains_<Pols,    outValue_<15> >::type >::type(),a15._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 49
// isConst = 1
// ret = 1 (void)
//
// innerCount = 1
// numArgs = 15 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)
// numVoids = 1
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
// typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 15 ) core::wrongNumberOfArguments(lcc_nargs,15);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13, core::T_sp arg14 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<14> >::type,
typename Contains_<Pols,    outValue_<14> >::type >::type(),a14._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 50
// isConst = 1
// ret = 1 (void)
//
// innerCount = 2
// numArgs = 14 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)
// numVoids = 2
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 14 ) core::wrongNumberOfArguments(lcc_nargs,14);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<13> >::type,
typename Contains_<Pols,    outValue_<13> >::type >::type(),a13._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 51
// isConst = 1
// ret = 1 (void)
//
// innerCount = 3
// numArgs = 13 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)
// numVoids = 3
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 13 ) core::wrongNumberOfArguments(lcc_nargs,13);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11, core::T_sp arg12 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<12> >::type,
typename Contains_<Pols,    outValue_<12> >::type >::type(),a12._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 52
// isConst = 1
// ret = 1 (void)
//
// innerCount = 4
// numArgs = 12 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)
// numVoids = 4
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 12 ) core::wrongNumberOfArguments(lcc_nargs,12);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) , frame::Value(frameImpl,11)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<11> >::type,
typename Contains_<Pols,    outValue_<11> >::type >::type(),a11._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 53
// isConst = 1
// ret = 1 (void)
//
// innerCount = 5
// numArgs = 11 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)
// numVoids = 5
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 11 ) core::wrongNumberOfArguments(lcc_nargs,11);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<10> >::type,
typename Contains_<Pols,    outValue_<10> >::type >::type(),a10._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 54
// isConst = 1
// ret = 1 (void)
//
// innerCount = 6
// numArgs = 10 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)
// numVoids = 6
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 10 ) core::wrongNumberOfArguments(lcc_nargs,10);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<9> >::type,
typename Contains_<Pols,    outValue_<9> >::type >::type(),a9._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 55
// isConst = 1
// ret = 1 (void)
//
// innerCount = 7
// numArgs = 9 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)
// numVoids = 7
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 9 ) core::wrongNumberOfArguments(lcc_nargs,9);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<8> >::type,
typename Contains_<Pols,    outValue_<8> >::type >::type(),a8._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 56
// isConst = 1
// ret = 1 (void)
//
// innerCount = 8
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 8
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 8 ) core::wrongNumberOfArguments(lcc_nargs,8);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) , frame::Value(frameImpl,7)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6, core::T_sp arg7 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<7> >::type,
typename Contains_<Pols,    outValue_<7> >::type >::type(),a7._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 57
// isConst = 1
// ret = 1 (void)
//
// innerCount = 9
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 9
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 7 ) core::wrongNumberOfArguments(lcc_nargs,7);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<6> >::type,
typename Contains_<Pols,    outValue_<6> >::type >::type(),a6._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 58
// isConst = 1
// ret = 1 (void)
//
// innerCount = 10
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 10
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4, ARG5)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 6 ) core::wrongNumberOfArguments(lcc_nargs,6);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4, core::T_sp arg5 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<5> >::type,
typename Contains_<Pols,    outValue_<5> >::type >::type(),a5._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 59
// isConst = 1
// ret = 1 (void)
//
// innerCount = 11
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 11
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3, ARG4)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 5 ) core::wrongNumberOfArguments(lcc_nargs,5);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3) , frame::Value(frameImpl,4)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<4> >::type,
typename Contains_<Pols,    outValue_<4> >::type >::type(),a4._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 60
// isConst = 1
// ret = 1 (void)
//
// innerCount = 12
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 12
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2, ARG3)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 4 ) core::wrongNumberOfArguments(lcc_nargs,4);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) , frame::Value(frameImpl,
    3)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<3> >::type,
typename Contains_<Pols,    outValue_<3> >::type >::type(),a3._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 61
// isConst = 1
// ret = 1 (void)
//
// innerCount = 13
// numArgs = 3 (ARG1, ARG2)
// numVoids = 13
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1, ARG2) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1, ARG2)> Type;
typedef void (OT::ExternalType::*Type)( ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 3 ) core::wrongNumberOfArguments(lcc_nargs,3);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<2> >::type,
typename Contains_<Pols,    outValue_<2> >::type >::type(),a2._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 62
// isConst = 1
// ret = 1 (void)
//
// innerCount = 14
// numArgs = 2 (ARG1)
// numVoids = 14
//
/* Specialization  */
template <typename Pols,  typename OT ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ARG1) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,ARG1)> Type;
typedef void (OT::ExternalType::*Type)( ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 2 ) core::wrongNumberOfArguments(lcc_nargs,2);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

LCC_RETURN invoke( core::T_sp arg0  , core::T_sp arg1 )
{
translate::from_object<ARG1> a1(arg1);
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<1> >::type,
typename Contains_<Pols,    outValue_<1> >::type >::type(),a1._v);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};
// TEMPLATE_TOP
// template_ = 63
// isConst = 1
// ret = 1 (void)
//
// innerCount = 15
// numArgs = 1 ()
// numVoids = 15
//
/* Specialization  */
template <typename Pols,  typename OT  >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::ExternalType::*)( ) const >
: public BuiltinClosure {
public:
virtual const char* describe() const {return "IndirectVariadicMethoid";};
typedef BuiltinClosure TemplatedBase;
public:
//        typedef std::function<void (OT& ,)> Type;
typedef void (OT::ExternalType::*Type)( ) const;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
//int countPureOutValues = CountPureOutValues<Pols>::value;
//if ( lcc_nargs != 1 ) core::wrongNumberOfArguments(lcc_nargs,1);
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0)  );
}

LCC_RETURN invoke( core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot(gc::As<gc::smart_ptr<OT>>(arg0));
((*(ot->wrappedPtr())).*(this->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
ReturnValueWhen(returnValues,oidx,
typename or_<typename Contains_<Pols,pureOutValue_<0> >::type,
typename Contains_<Pols,    outValue_<0> >::type >::type(),arg0);
return gctools::multiple_values<T_O>(returnValues.valueGet(0,oidx),oidx);
}

};



