// This file was GENERATED by command:
//     pump.py wrappers_functoids.pmp
// DO NOT EDIT BY HAND!!!


// ret = 0  RetSV
// numArgs = 18
// numVoids = 0
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15,typename ARG16,typename ARG17 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16, ARG17) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15,
    ARG16, ARG17) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16,
    ARG17);
Type fptr;
public:
enum { NumParams = 18 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),18);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
translate::from_object<ARG16> a16(core::T_sp((gc::Tagged)(*fargs)[16]));
translate::from_object<ARG17> a17(core::T_sp((gc::Tagged)(*fargs)[17]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v,
    a16._v,a17._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 17
// numVoids = 1
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15,typename ARG16 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15,
    ARG16) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16);
Type fptr;
public:
enum { NumParams = 17 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),17);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
translate::from_object<ARG16> a16(core::T_sp((gc::Tagged)(*fargs)[16]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v,
    a16._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 16
// numVoids = 2
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15);
Type fptr;
public:
enum { NumParams = 16 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 15
// numVoids = 3
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14);
Type fptr;
public:
enum { NumParams = 15 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 14
// numVoids = 4
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13);
Type fptr;
public:
enum { NumParams = 14 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 13
// numVoids = 5
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
enum { NumParams = 13 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 12
// numVoids = 6
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
enum { NumParams = 12 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 11
// numVoids = 7
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
enum { NumParams = 11 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 10
// numVoids = 8
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
enum { NumParams = 10 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 9
// numVoids = 9
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
enum { NumParams = 9 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 8
// numVoids = 10
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
enum { NumParams = 8 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 7
// numVoids = 11
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
enum { NumParams = 7 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 6
// numVoids = 12
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
enum { NumParams = 6 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 5
// numVoids = 13
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3, ARG4) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3, ARG4) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
enum { NumParams = 5 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 4
// numVoids = 14
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2, ARG3) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2, ARG3) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
enum { NumParams = 4 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 3
// numVoids = 15
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctor
<RT (ARG0, ARG1, ARG2) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1, ARG2) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1, ARG2);
Type fptr;
public:
enum { NumParams = 3 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
RT retval =  closure->fptr(a0._v,a1._v,a2._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 2
// numVoids = 16
/* Specialization */
template <typename RT , typename ARG0,typename ARG1 >
class VariadicFunctor
<RT (ARG0, ARG1) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0, ARG1) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0, ARG1);
Type fptr;
public:
enum { NumParams = 2 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
RT retval =  closure->fptr(a0._v,a1._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 1
// numVoids = 17
/* Specialization */
template <typename RT , typename ARG0 >
class VariadicFunctor
<RT (ARG0) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT (ARG0) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) (ARG0);
Type fptr;
public:
enum { NumParams = 1 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
RT retval =  closure->fptr(a0._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 0
// numVoids = 18
/* Specialization */
template <typename RT   >
class VariadicFunctor
<RT () >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <RT () > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef RT(*Type) ();
Type fptr;
public:
enum { NumParams = 0 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
RT retval =  closure->fptr();
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 1  RetVoid
// numArgs = 18
// numVoids = 0
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,typename ARG15,
    typename ARG16,typename ARG17 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16, ARG17) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15,
    ARG16, ARG17) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16,
    ARG17);
Type fptr;
public:
enum { NumParams = 18 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),18);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
translate::from_object<ARG16> a16(core::T_sp((gc::Tagged)(*fargs)[16]));
translate::from_object<ARG17> a17(core::T_sp((gc::Tagged)(*fargs)[17]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v,a16._v,a17._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 17
// numVoids = 1
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,typename ARG15,
    typename ARG16 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15,
    ARG16) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15, ARG16);
Type fptr;
public:
enum { NumParams = 17 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),17);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
translate::from_object<ARG16> a16(core::T_sp((gc::Tagged)(*fargs)[16]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v,a16._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 16
// numVoids = 2
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,typename ARG15 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15);
Type fptr;
public:
enum { NumParams = 16 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 15
// numVoids = 3
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14);
Type fptr;
public:
enum { NumParams = 15 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 14
// numVoids = 4
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13);
Type fptr;
public:
enum { NumParams = 14 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 13
// numVoids = 5
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
enum { NumParams = 13 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 12
// numVoids = 6
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
enum { NumParams = 12 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 11
// numVoids = 7
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
enum { NumParams = 11 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 10
// numVoids = 8
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
enum { NumParams = 10 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 9
// numVoids = 9
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
enum { NumParams = 9 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 8
// numVoids = 10
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
enum { NumParams = 8 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 7
// numVoids = 11
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
enum { NumParams = 7 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 6
// numVoids = 12
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
enum { NumParams = 6 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 5
// numVoids = 13
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3, ARG4) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3, ARG4) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
enum { NumParams = 5 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 4
// numVoids = 14
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2, ARG3) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2, ARG3) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
enum { NumParams = 4 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
closure->fptr(a0._v,a1._v,a2._v,a3._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 3
// numVoids = 15
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctor
<void(ARG0, ARG1, ARG2) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1, ARG2) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1, ARG2);
Type fptr;
public:
enum { NumParams = 3 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
closure->fptr(a0._v,a1._v,a2._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 2
// numVoids = 16
/* Specialization */
template < typename ARG0,typename ARG1 >
class VariadicFunctor
<void(ARG0, ARG1) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0, ARG1) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0, ARG1);
Type fptr;
public:
enum { NumParams = 2 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
closure->fptr(a0._v,a1._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 1
// numVoids = 17
/* Specialization */
template < typename ARG0 >
class VariadicFunctor
<void(ARG0) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void(ARG0) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) (ARG0);
Type fptr;
public:
enum { NumParams = 1 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
closure->fptr(a0._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 0
// numVoids = 18
/* Specialization */
template <  >
class VariadicFunctor
<void() >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <void() > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef void(*Type) ();
Type fptr;
public:
enum { NumParams = 0 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
closure->fptr();
return Values0<core::T_O>();
}

};
// ret = 2  RetMV
// numArgs = 18
// numVoids = 0
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15,typename ARG16,typename ARG17 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15,
    ARG16, ARG17) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,
    ARG12, ARG13, ARG14, ARG15, ARG16, ARG17) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13, ARG14, ARG15, ARG16, ARG17);
Type fptr;
public:
enum { NumParams = 18 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),18);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
translate::from_object<ARG16> a16(core::T_sp((gc::Tagged)(*fargs)[16]));
translate::from_object<ARG17> a17(core::T_sp((gc::Tagged)(*fargs)[17]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v,a15._v,a16._v,a17._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 17
// numVoids = 1
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15,typename ARG16 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15,
    ARG16) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,
    ARG12, ARG13, ARG14, ARG15, ARG16) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13, ARG14, ARG15, ARG16);
Type fptr;
public:
enum { NumParams = 17 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),17);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
translate::from_object<ARG16> a16(core::T_sp((gc::Tagged)(*fargs)[16]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v,a15._v,a16._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 16
// numVoids = 2
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,
    ARG12, ARG13, ARG14, ARG15) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13, ARG14, ARG15);
Type fptr;
public:
enum { NumParams = 16 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),16);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
translate::from_object<ARG15> a15(core::T_sp((gc::Tagged)(*fargs)[15]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v,a15._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 15
// numVoids = 3
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,
    ARG12, ARG13, ARG14) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13, ARG14);
Type fptr;
public:
enum { NumParams = 15 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),15);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
translate::from_object<ARG14> a14(core::T_sp((gc::Tagged)(*fargs)[14]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 14
// numVoids = 4
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,
    ARG12, ARG13) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13);
Type fptr;
public:
enum { NumParams = 14 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),14);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
translate::from_object<ARG13> a13(core::T_sp((gc::Tagged)(*fargs)[13]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 13
// numVoids = 5
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,
    ARG12) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
enum { NumParams = 13 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),13);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
translate::from_object<ARG12> a12(core::T_sp((gc::Tagged)(*fargs)[12]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 12
// numVoids = 6
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10,
    ARG11) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
enum { NumParams = 12 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),12);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
translate::from_object<ARG11> a11(core::T_sp((gc::Tagged)(*fargs)[11]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 11
// numVoids = 7
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
enum { NumParams = 11 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),11);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
translate::from_object<ARG10> a10(core::T_sp((gc::Tagged)(*fargs)[10]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 10
// numVoids = 8
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
enum { NumParams = 10 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),10);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
translate::from_object<ARG9> a9(core::T_sp((gc::Tagged)(*fargs)[9]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 9
// numVoids = 9
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
enum { NumParams = 9 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),9);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
translate::from_object<ARG8> a8(core::T_sp((gc::Tagged)(*fargs)[8]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 8
// numVoids = 10
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
enum { NumParams = 8 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
translate::from_object<ARG7> a7(core::T_sp((gc::Tagged)(*fargs)[7]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 7
// numVoids = 11
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
enum { NumParams = 7 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
translate::from_object<ARG6> a6(core::T_sp((gc::Tagged)(*fargs)[6]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 6
// numVoids = 12
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
enum { NumParams = 6 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
translate::from_object<ARG5> a5(core::T_sp((gc::Tagged)(*fargs)[5]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 5
// numVoids = 13
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
enum { NumParams = 5 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
translate::from_object<ARG4> a4(core::T_sp((gc::Tagged)(*fargs)[4]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 4
// numVoids = 14
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
enum { NumParams = 4 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
translate::from_object<ARG3> a3(core::T_sp((gc::Tagged)(*fargs)[3]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v,a3._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 3
// numVoids = 15
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1, ARG2) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2);
Type fptr;
public:
enum { NumParams = 3 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
translate::from_object<ARG2> a2(core::T_sp((gc::Tagged)(*fargs)[2]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v,a2._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 2
// numVoids = 16
/* Specialization */
template <typename RT , typename ARG0,typename ARG1 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0, ARG1) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0, ARG1) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1);
Type fptr;
public:
enum { NumParams = 2 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
translate::from_object<ARG1> a1(core::T_sp((gc::Tagged)(*fargs)[1]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v,a1._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 1
// numVoids = 17
/* Specialization */
template <typename RT , typename ARG0 >
class VariadicFunctor
<gctools::multiple_values<RT>(ARG0) >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>(ARG0) > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) (ARG0);
Type fptr;
public:
enum { NumParams = 1 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(fargs,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(fargs);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<ARG0> a0(core::T_sp((gc::Tagged)(*fargs)[0]));
gctools::multiple_values<RT> retval =  closure->fptr(a0._v);
return retval.as_return_type();
}

};
// ret = 2  RetMV
// numArgs = 0
// numVoids = 18
/* Specialization */
template <typename RT   >
class VariadicFunctor
<gctools::multiple_values<RT>() >
: public BuiltinClosure_O {
public:
typedef VariadicFunctor <gctools::multiple_values<RT>() > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctor";};

typedef gctools::multiple_values<RT>(*Type) ();
Type fptr;
public:
enum { NumParams = 0 };
VariadicFunctor(T_sp name, Symbol_sp funcType, Type ptr, SOURCE_INFO) : BuiltinClosure_O(&MyType::entry_point,name,funcType,
    SOURCE_INFO_PASS), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
static inline LCC_RETURN entry_point(LCC_ARGS_ELLIPSIS)
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
gctools::multiple_values<RT> retval =  closure->fptr();
return retval.as_return_type();
}

};



