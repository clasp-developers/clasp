// This file was GENERATED by command:
//     pump.py clbind_methoids.pmp
// DO NOT EDIT BY HAND!!!

//                                                                                    // TEMPLATE_TOP
// template_ = 0
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 0
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 0
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a7(frame->arg(7));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 1
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 1
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 1
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 2
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 2
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 2
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 3
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 3
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 3
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 4
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 4
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 4
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 5
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 5
// numArgs = 3 (ARG1, ARG2)
// numVoids = 5
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 6
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 6
// numArgs = 2 (ARG1)
// numVoids = 6
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 7
// isConst = 0
// ret = 0 (RetSV)
//
// innerCount = 7
// numArgs = 1 ()
// numVoids = 7
//
/* Specialization  */
template <typename Pols, typename OT , typename RT   >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( )  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( )  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ) ;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
RT retval =  ((*objPtr._v).*(closure->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 8
// isConst = 0
// ret = 1 (void)
//
// innerCount = 0
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 0
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a7(frame->arg(7));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 9
// isConst = 0
// ret = 1 (void)
//
// innerCount = 1
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 1
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 10
// isConst = 0
// ret = 1 (void)
//
// innerCount = 2
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 2
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 11
// isConst = 0
// ret = 1 (void)
//
// innerCount = 3
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 3
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 12
// isConst = 0
// ret = 1 (void)
//
// innerCount = 4
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 4
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 13
// isConst = 0
// ret = 1 (void)
//
// innerCount = 5
// numArgs = 3 (ARG1, ARG2)
// numVoids = 5
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 14
// isConst = 0
// ret = 1 (void)
//
// innerCount = 6
// numArgs = 2 (ARG1)
// numVoids = 6
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
((*objPtr._v).*(closure->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 15
// isConst = 0
// ret = 1 (void)
//
// innerCount = 7
// numArgs = 1 ()
// numVoids = 7
//
/* Specialization  */
template <typename Pols, typename OT   >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( )  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( )  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ) ;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
((*objPtr._v).*(closure->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
    return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 16
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 0
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 0
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a7(frame->arg(7));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 17
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 1
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 1
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 18
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 2
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 2
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 19
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 3
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 3
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 20
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 4
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 4
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 21
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 5
// numArgs = 3 (ARG1, ARG2)
// numVoids = 5
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 22
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 6
// numArgs = 2 (ARG1)
// numVoids = 6
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1)  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1)  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 23
// isConst = 0
// ret = 2 (RetSV)
//
// innerCount = 7
// numArgs = 1 ()
// numVoids = 7
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT   >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( )  >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( )  > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ) ;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 24
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 0
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 0
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a7(frame->arg(7));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 25
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 1
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 1
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 26
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 2
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 2
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 27
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 3
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 3
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3, ARG4) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 28
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 4
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 4
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2, ARG3) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 29
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 5
// numArgs = 3 (ARG1, ARG2)
// numVoids = 5
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1, ARG2) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1, ARG2) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 30
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 6
// numArgs = 2 (ARG1)
// numVoids = 6
//
/* Specialization  */
template <typename Pols, typename OT , typename RT  ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ARG1) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ARG1) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
RT retval =  ((*objPtr._v).*(closure->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 31
// isConst = 1
// ret = 0 (RetSV)
//
// innerCount = 7
// numArgs = 1 ()
// numVoids = 7
//
/* Specialization  */
template <typename Pols, typename OT , typename RT   >
class IndirectVariadicMethoid
< Pols,OT ,RT (OT::*)( ) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,RT (OT::*)( ) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef RT (OT::*Type)( ) const;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
RT retval =  ((*objPtr._v).*(closure->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
return LCC_RETURN(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 32
// isConst = 1
// ret = 1 (void)
//
// innerCount = 0
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 0
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a7(frame->arg(7));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 33
// isConst = 1
// ret = 1 (void)
//
// innerCount = 1
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 1
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 34
// isConst = 1
// ret = 1 (void)
//
// innerCount = 2
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 2
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 35
// isConst = 1
// ret = 1 (void)
//
// innerCount = 3
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 3
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3, ARG4) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 36
// isConst = 1
// ret = 1 (void)
//
// innerCount = 4
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 4
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2, ARG3) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 37
// isConst = 1
// ret = 1 (void)
//
// innerCount = 5
// numArgs = 3 (ARG1, ARG2)
// numVoids = 5
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1, ARG2) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1, ARG2) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
((*objPtr._v).*(closure->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 38
// isConst = 1
// ret = 1 (void)
//
// innerCount = 6
// numArgs = 2 (ARG1)
// numVoids = 6
//
/* Specialization  */
template <typename Pols, typename OT  ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ARG1) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ARG1) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
((*objPtr._v).*(closure->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                   ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 39
// isConst = 1
// ret = 1 (void)
//
// innerCount = 7
// numArgs = 1 ()
// numVoids = 7
//
/* Specialization  */
template <typename Pols, typename OT   >
class IndirectVariadicMethoid
< Pols,OT ,void(OT::*)( ) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT ,void(OT::*)( ) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef void (OT::*Type)( ) const;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
((*objPtr._v).*(closure->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;
    return LCC_RETURN(returnValues.valueGet(0,oidx).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 40
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 0
// numArgs = 8 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
// numVoids = 0
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a7(frame->arg(7));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 41
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 1
// numArgs = 7 (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)
// numVoids = 1
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a6(frame->arg(6));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 42
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 2
// numArgs = 6 (ARG1, ARG2, ARG3, ARG4, ARG5)
// numVoids = 2
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a5(frame->arg(5));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 43
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 3
// numArgs = 5 (ARG1, ARG2, ARG3, ARG4)
// numVoids = 3
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3, ARG4) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a4(frame->arg(4));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 44
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 4
// numArgs = 4 (ARG1, ARG2, ARG3)
// numVoids = 4
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2,typename ARG3 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2, ARG3) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a3(frame->arg(3));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 45
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 5
// numArgs = 3 (ARG1, ARG2)
// numVoids = 5
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1,typename ARG2 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1, ARG2) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a2(frame->arg(2));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 46
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 6
// numArgs = 2 (ARG1)
// numVoids = 6
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT  ,typename ARG1 >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ARG1) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a1(frame->arg(1));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))(a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);

return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};
// TEMPLATE_TOP
// template_ = 47
// isConst = 1
// ret = 2 (RetSV)
//
// innerCount = 7
// numArgs = 1 ()
// numVoids = 7
//
/* Specialization  */
template <typename Pols, typename OT , typename UPRT   >
class IndirectVariadicMethoid
< Pols,OT , std::unique_ptr<UPRT> (OT::*)( ) const >
: public core::BuiltinClosure_O {
public:
typedef IndirectVariadicMethoid < Pols,OT , std::unique_ptr<UPRT> (OT::*)( ) const > MyType;
typedef BuiltinClosure_O TemplatedBase;
public:
virtual const char* describe() const { return "IndirectVariadicMethoid"; };
typedef std::unique_ptr<UPRT> (OT::*Type)( ) const;
Type mptr;
public:
enum { NumParams = 1 };
IndirectVariadicMethoid(core::T_sp name, Type ptr) : core::BuiltinClosure_O(entry_point,name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};

static inline LCC_RETURN LISP_CALLING_CONVENTION()
{
MyType* closure = gctools::untag_general<MyType*>((MyType*)lcc_closure);
INCREMENT_FUNCTION_CALL_COUNTER(closure);
INITIALIZE_VA_LIST();
INVOCATION_HISTORY_FRAME();
MAKE_STACK_FRAME(frame,closure->asSmartPtr().raw_(),1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(closure->asSmartPtr(),closure->_lambdaListHandler,scope,LCC_PASS_ARGS_LLH);
translate::from_object<OT*> objPtr(frame->arg(0));
std::unique_ptr<UPRT> retval =  ((*objPtr._v).*(closure->mptr))();
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
return LCC_RETURN(translate::to_object<std::unique_ptr<UPRT>,typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)).raw_(),oidx);
}
};

